/*
 * Journey Analytics API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 6.35.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.alterian.ja.api;

import com.alterian.ja.ApiCallback;
import com.alterian.ja.ApiClient;
import com.alterian.ja.ApiException;
import com.alterian.ja.ApiResponse;
import com.alterian.ja.Configuration;
import com.alterian.ja.Pair;
import com.alterian.ja.ProgressRequestBody;
import com.alterian.ja.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import com.alterian.ja.model.AUTHChangePasswordDefaultResponse;
import com.alterian.ja.model.CreateChannelRequest;
import com.alterian.ja.model.CreateClientDefaultResponse;
import com.alterian.ja.model.CreateEventStreamGroupRequest;
import com.alterian.ja.model.CreateEventStreamRequest;
import com.alterian.ja.model.CreateIdealisedJourneyRequest;
import com.alterian.ja.model.CreateSankeyFavouriteRequest;
import com.alterian.ja.model.CreateVisualisationFavouriteRequest;
import com.alterian.ja.model.DeleteChannelRequest;
import com.alterian.ja.model.DeleteEventStreamCustomerColumnsFromGroupRequest;
import com.alterian.ja.model.DeleteEventStreamCustomerColumnsRequest;
import com.alterian.ja.model.DeleteEventStreamGroupRequest;
import com.alterian.ja.model.DeleteEventStreamRequest;
import com.alterian.ja.model.DeleteIdealisedJourneyRequest;
import com.alterian.ja.model.DeleteSankeyFavouritesRequest;
import com.alterian.ja.model.DeleteVisualisationFavouritesRequest;
import com.alterian.ja.model.ExportEventStreamInteractionRequest;
import java.io.File;
import com.alterian.ja.model.GetChannelsDefaultResponse;
import com.alterian.ja.model.GetClientSetsRequest;
import com.alterian.ja.model.GetDataSourceUsersDefaultResponse;
import com.alterian.ja.model.GetEventRecordsDefaultResponse;
import com.alterian.ja.model.GetEventRecordsRequest;
import com.alterian.ja.model.GetEventStreamAggregatesRequest;
import com.alterian.ja.model.GetEventStreamChannelsRequest;
import com.alterian.ja.model.GetEventStreamDecodeMappingsDefaultResponse;
import com.alterian.ja.model.GetEventStreamDecodeMappingsRequest;
import com.alterian.ja.model.GetEventStreamDecodeTargetDiscretesDefaultResponse;
import com.alterian.ja.model.GetEventStreamDecodeTargetDiscretesRequest;
import com.alterian.ja.model.GetEventStreamDefaultResponse;
import com.alterian.ja.model.GetEventStreamDiscreteValuesDefaultResponse;
import com.alterian.ja.model.GetEventStreamDiscreteValuesRequest;
import com.alterian.ja.model.GetEventStreamModelsDefaultResponse;
import com.alterian.ja.model.GetEventStreamModelsRequest;
import com.alterian.ja.model.GetEventStreamRequest;
import com.alterian.ja.model.GetEventStreamsDefaultResponse;
import com.alterian.ja.model.GetFieldTransformationDiscreteValuesRequest;
import com.alterian.ja.model.GetFieldTransformationMappingsDefaultResponse;
import com.alterian.ja.model.GetFieldTransformationMappingsRequest;
import com.alterian.ja.model.GetIdealisedJourneysDefaultResponse;
import com.alterian.ja.model.GetSankeyFavouritesDefaultResponse;
import com.alterian.ja.model.GetSankeyFavouritesRequest;
import com.alterian.ja.model.GetVisualisationFavouritesDefaultResponse;
import com.alterian.ja.model.QueryEventStreamCountDefaultResponse;
import com.alterian.ja.model.QueryEventStreamCountRequest;
import com.alterian.ja.model.QueryEventStreamDefaultResponse;
import com.alterian.ja.model.QueryEventStreamRequest;
import com.alterian.ja.model.QueryEventStreamTransitionRequest;
import com.alterian.ja.model.RunSequencePredictorDefaultResponse;
import com.alterian.ja.model.RunSequencePredictorRequest;
import com.alterian.ja.model.UpdateChannelRequest;
import com.alterian.ja.model.UpdateEventStreamFieldTransformListsRequest;
import com.alterian.ja.model.UpdateIdealisedJourneyRequest;
import com.alterian.ja.model.UpdateSankeyFavouriteRequest;
import com.alterian.ja.model.UpdateVisualisationFavouriteRequest;
import com.alterian.ja.model.UpsertEventStreamCustomerColumnsRequest;
import com.alterian.ja.model.UpsertEventStreamCustomerColumnsToGroupRequest;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class EventStreamsApi {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public EventStreamsApi() {
        this(Configuration.getDefaultApiClient());
    }

    public EventStreamsApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    /**
     * Build call for createChannel
     * @param createChannelRequest Create a channel colour mapping (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call createChannelCall(CreateChannelRequest createChannelRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = createChannelRequest;

        // create path and map variables
        String localVarPath = "/CreateChannel";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "TokenAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call createChannelValidateBeforeCall(CreateChannelRequest createChannelRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'createChannelRequest' is set
        if (createChannelRequest == null) {
            throw new ApiException("Missing the required parameter 'createChannelRequest' when calling createChannel(Async)");
        }

        return createChannelCall(createChannelRequest, _callback);

    }

    /**
     * Create a channel colour mapping
     * Create a channel colour mapping
     * @param createChannelRequest Create a channel colour mapping (required)
     * @return CreateClientDefaultResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public CreateClientDefaultResponse createChannel(CreateChannelRequest createChannelRequest) throws ApiException {
        ApiResponse<CreateClientDefaultResponse> localVarResp = createChannelWithHttpInfo(createChannelRequest);
        return localVarResp.getData();
    }

    /**
     * Create a channel colour mapping
     * Create a channel colour mapping
     * @param createChannelRequest Create a channel colour mapping (required)
     * @return ApiResponse&lt;CreateClientDefaultResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<CreateClientDefaultResponse> createChannelWithHttpInfo(CreateChannelRequest createChannelRequest) throws ApiException {
        okhttp3.Call localVarCall = createChannelValidateBeforeCall(createChannelRequest, null);
        Type localVarReturnType = new TypeToken<CreateClientDefaultResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Create a channel colour mapping (asynchronously)
     * Create a channel colour mapping
     * @param createChannelRequest Create a channel colour mapping (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call createChannelAsync(CreateChannelRequest createChannelRequest, final ApiCallback<CreateClientDefaultResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = createChannelValidateBeforeCall(createChannelRequest, _callback);
        Type localVarReturnType = new TypeToken<CreateClientDefaultResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for createEventStream
     * @param createEventStreamRequest Creates an event stream, including a datasource and a DDE queue (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call createEventStreamCall(CreateEventStreamRequest createEventStreamRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = createEventStreamRequest;

        // create path and map variables
        String localVarPath = "/CreateEventStream";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "TokenAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call createEventStreamValidateBeforeCall(CreateEventStreamRequest createEventStreamRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'createEventStreamRequest' is set
        if (createEventStreamRequest == null) {
            throw new ApiException("Missing the required parameter 'createEventStreamRequest' when calling createEventStream(Async)");
        }

        return createEventStreamCall(createEventStreamRequest, _callback);

    }

    /**
     * Creates an event stream, including a datasource and a DDE queue
     * Creates an event stream, including a datasource and a DDE queue
     * @param createEventStreamRequest Creates an event stream, including a datasource and a DDE queue (required)
     * @return CreateClientDefaultResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public CreateClientDefaultResponse createEventStream(CreateEventStreamRequest createEventStreamRequest) throws ApiException {
        ApiResponse<CreateClientDefaultResponse> localVarResp = createEventStreamWithHttpInfo(createEventStreamRequest);
        return localVarResp.getData();
    }

    /**
     * Creates an event stream, including a datasource and a DDE queue
     * Creates an event stream, including a datasource and a DDE queue
     * @param createEventStreamRequest Creates an event stream, including a datasource and a DDE queue (required)
     * @return ApiResponse&lt;CreateClientDefaultResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<CreateClientDefaultResponse> createEventStreamWithHttpInfo(CreateEventStreamRequest createEventStreamRequest) throws ApiException {
        okhttp3.Call localVarCall = createEventStreamValidateBeforeCall(createEventStreamRequest, null);
        Type localVarReturnType = new TypeToken<CreateClientDefaultResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Creates an event stream, including a datasource and a DDE queue (asynchronously)
     * Creates an event stream, including a datasource and a DDE queue
     * @param createEventStreamRequest Creates an event stream, including a datasource and a DDE queue (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call createEventStreamAsync(CreateEventStreamRequest createEventStreamRequest, final ApiCallback<CreateClientDefaultResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = createEventStreamValidateBeforeCall(createEventStreamRequest, _callback);
        Type localVarReturnType = new TypeToken<CreateClientDefaultResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for createEventStreamGroup
     * @param createEventStreamGroupRequest Creates an event stream group, including a datasource and a DDE queue for each target (dev/test/prod) (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call createEventStreamGroupCall(CreateEventStreamGroupRequest createEventStreamGroupRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = createEventStreamGroupRequest;

        // create path and map variables
        String localVarPath = "/CreateEventStreamGroup";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "TokenAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call createEventStreamGroupValidateBeforeCall(CreateEventStreamGroupRequest createEventStreamGroupRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'createEventStreamGroupRequest' is set
        if (createEventStreamGroupRequest == null) {
            throw new ApiException("Missing the required parameter 'createEventStreamGroupRequest' when calling createEventStreamGroup(Async)");
        }

        return createEventStreamGroupCall(createEventStreamGroupRequest, _callback);

    }

    /**
     * Creates an event stream group, including a datasource and a DDE queue for each target (dev/test/prod)
     * Creates an event stream group, including a datasource and a DDE queue for each target (dev/test/prod)
     * @param createEventStreamGroupRequest Creates an event stream group, including a datasource and a DDE queue for each target (dev/test/prod) (required)
     * @return CreateClientDefaultResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public CreateClientDefaultResponse createEventStreamGroup(CreateEventStreamGroupRequest createEventStreamGroupRequest) throws ApiException {
        ApiResponse<CreateClientDefaultResponse> localVarResp = createEventStreamGroupWithHttpInfo(createEventStreamGroupRequest);
        return localVarResp.getData();
    }

    /**
     * Creates an event stream group, including a datasource and a DDE queue for each target (dev/test/prod)
     * Creates an event stream group, including a datasource and a DDE queue for each target (dev/test/prod)
     * @param createEventStreamGroupRequest Creates an event stream group, including a datasource and a DDE queue for each target (dev/test/prod) (required)
     * @return ApiResponse&lt;CreateClientDefaultResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<CreateClientDefaultResponse> createEventStreamGroupWithHttpInfo(CreateEventStreamGroupRequest createEventStreamGroupRequest) throws ApiException {
        okhttp3.Call localVarCall = createEventStreamGroupValidateBeforeCall(createEventStreamGroupRequest, null);
        Type localVarReturnType = new TypeToken<CreateClientDefaultResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Creates an event stream group, including a datasource and a DDE queue for each target (dev/test/prod) (asynchronously)
     * Creates an event stream group, including a datasource and a DDE queue for each target (dev/test/prod)
     * @param createEventStreamGroupRequest Creates an event stream group, including a datasource and a DDE queue for each target (dev/test/prod) (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call createEventStreamGroupAsync(CreateEventStreamGroupRequest createEventStreamGroupRequest, final ApiCallback<CreateClientDefaultResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = createEventStreamGroupValidateBeforeCall(createEventStreamGroupRequest, _callback);
        Type localVarReturnType = new TypeToken<CreateClientDefaultResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for createIdealisedJourney
     * @param createIdealisedJourneyRequest Create an Idealised Journey (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call createIdealisedJourneyCall(CreateIdealisedJourneyRequest createIdealisedJourneyRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = createIdealisedJourneyRequest;

        // create path and map variables
        String localVarPath = "/CreateIdealisedJourney";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "TokenAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call createIdealisedJourneyValidateBeforeCall(CreateIdealisedJourneyRequest createIdealisedJourneyRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'createIdealisedJourneyRequest' is set
        if (createIdealisedJourneyRequest == null) {
            throw new ApiException("Missing the required parameter 'createIdealisedJourneyRequest' when calling createIdealisedJourney(Async)");
        }

        return createIdealisedJourneyCall(createIdealisedJourneyRequest, _callback);

    }

    /**
     * Create an Idealised Journey
     * Create an Idealised Journey
     * @param createIdealisedJourneyRequest Create an Idealised Journey (required)
     * @return CreateClientDefaultResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public CreateClientDefaultResponse createIdealisedJourney(CreateIdealisedJourneyRequest createIdealisedJourneyRequest) throws ApiException {
        ApiResponse<CreateClientDefaultResponse> localVarResp = createIdealisedJourneyWithHttpInfo(createIdealisedJourneyRequest);
        return localVarResp.getData();
    }

    /**
     * Create an Idealised Journey
     * Create an Idealised Journey
     * @param createIdealisedJourneyRequest Create an Idealised Journey (required)
     * @return ApiResponse&lt;CreateClientDefaultResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<CreateClientDefaultResponse> createIdealisedJourneyWithHttpInfo(CreateIdealisedJourneyRequest createIdealisedJourneyRequest) throws ApiException {
        okhttp3.Call localVarCall = createIdealisedJourneyValidateBeforeCall(createIdealisedJourneyRequest, null);
        Type localVarReturnType = new TypeToken<CreateClientDefaultResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Create an Idealised Journey (asynchronously)
     * Create an Idealised Journey
     * @param createIdealisedJourneyRequest Create an Idealised Journey (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call createIdealisedJourneyAsync(CreateIdealisedJourneyRequest createIdealisedJourneyRequest, final ApiCallback<CreateClientDefaultResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = createIdealisedJourneyValidateBeforeCall(createIdealisedJourneyRequest, _callback);
        Type localVarReturnType = new TypeToken<CreateClientDefaultResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for createSankeyFavourite
     * @param createSankeyFavouriteRequest Create a Sankey Favourite (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call createSankeyFavouriteCall(CreateSankeyFavouriteRequest createSankeyFavouriteRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = createSankeyFavouriteRequest;

        // create path and map variables
        String localVarPath = "/CreateSankeyFavourite";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "TokenAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call createSankeyFavouriteValidateBeforeCall(CreateSankeyFavouriteRequest createSankeyFavouriteRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'createSankeyFavouriteRequest' is set
        if (createSankeyFavouriteRequest == null) {
            throw new ApiException("Missing the required parameter 'createSankeyFavouriteRequest' when calling createSankeyFavourite(Async)");
        }

        return createSankeyFavouriteCall(createSankeyFavouriteRequest, _callback);

    }

    /**
     * Create a Sankey Favourite
     * Create a Sankey Favourite
     * @param createSankeyFavouriteRequest Create a Sankey Favourite (required)
     * @return CreateClientDefaultResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public CreateClientDefaultResponse createSankeyFavourite(CreateSankeyFavouriteRequest createSankeyFavouriteRequest) throws ApiException {
        ApiResponse<CreateClientDefaultResponse> localVarResp = createSankeyFavouriteWithHttpInfo(createSankeyFavouriteRequest);
        return localVarResp.getData();
    }

    /**
     * Create a Sankey Favourite
     * Create a Sankey Favourite
     * @param createSankeyFavouriteRequest Create a Sankey Favourite (required)
     * @return ApiResponse&lt;CreateClientDefaultResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<CreateClientDefaultResponse> createSankeyFavouriteWithHttpInfo(CreateSankeyFavouriteRequest createSankeyFavouriteRequest) throws ApiException {
        okhttp3.Call localVarCall = createSankeyFavouriteValidateBeforeCall(createSankeyFavouriteRequest, null);
        Type localVarReturnType = new TypeToken<CreateClientDefaultResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Create a Sankey Favourite (asynchronously)
     * Create a Sankey Favourite
     * @param createSankeyFavouriteRequest Create a Sankey Favourite (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call createSankeyFavouriteAsync(CreateSankeyFavouriteRequest createSankeyFavouriteRequest, final ApiCallback<CreateClientDefaultResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = createSankeyFavouriteValidateBeforeCall(createSankeyFavouriteRequest, _callback);
        Type localVarReturnType = new TypeToken<CreateClientDefaultResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for createVisualisationFavourite
     * @param createVisualisationFavouriteRequest Create a Visualisation Favourite (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call createVisualisationFavouriteCall(CreateVisualisationFavouriteRequest createVisualisationFavouriteRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = createVisualisationFavouriteRequest;

        // create path and map variables
        String localVarPath = "/CreateVisualisationFavourite";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "TokenAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call createVisualisationFavouriteValidateBeforeCall(CreateVisualisationFavouriteRequest createVisualisationFavouriteRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'createVisualisationFavouriteRequest' is set
        if (createVisualisationFavouriteRequest == null) {
            throw new ApiException("Missing the required parameter 'createVisualisationFavouriteRequest' when calling createVisualisationFavourite(Async)");
        }

        return createVisualisationFavouriteCall(createVisualisationFavouriteRequest, _callback);

    }

    /**
     * Create a Visualisation Favourite
     * Create a Visualisation Favourite
     * @param createVisualisationFavouriteRequest Create a Visualisation Favourite (required)
     * @return CreateClientDefaultResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public CreateClientDefaultResponse createVisualisationFavourite(CreateVisualisationFavouriteRequest createVisualisationFavouriteRequest) throws ApiException {
        ApiResponse<CreateClientDefaultResponse> localVarResp = createVisualisationFavouriteWithHttpInfo(createVisualisationFavouriteRequest);
        return localVarResp.getData();
    }

    /**
     * Create a Visualisation Favourite
     * Create a Visualisation Favourite
     * @param createVisualisationFavouriteRequest Create a Visualisation Favourite (required)
     * @return ApiResponse&lt;CreateClientDefaultResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<CreateClientDefaultResponse> createVisualisationFavouriteWithHttpInfo(CreateVisualisationFavouriteRequest createVisualisationFavouriteRequest) throws ApiException {
        okhttp3.Call localVarCall = createVisualisationFavouriteValidateBeforeCall(createVisualisationFavouriteRequest, null);
        Type localVarReturnType = new TypeToken<CreateClientDefaultResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Create a Visualisation Favourite (asynchronously)
     * Create a Visualisation Favourite
     * @param createVisualisationFavouriteRequest Create a Visualisation Favourite (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call createVisualisationFavouriteAsync(CreateVisualisationFavouriteRequest createVisualisationFavouriteRequest, final ApiCallback<CreateClientDefaultResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = createVisualisationFavouriteValidateBeforeCall(createVisualisationFavouriteRequest, _callback);
        Type localVarReturnType = new TypeToken<CreateClientDefaultResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for deleteChannel
     * @param deleteChannelRequest Removed a channel and its associated colour from the channel list. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call deleteChannelCall(DeleteChannelRequest deleteChannelRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = deleteChannelRequest;

        // create path and map variables
        String localVarPath = "/DeleteChannel";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "TokenAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call deleteChannelValidateBeforeCall(DeleteChannelRequest deleteChannelRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'deleteChannelRequest' is set
        if (deleteChannelRequest == null) {
            throw new ApiException("Missing the required parameter 'deleteChannelRequest' when calling deleteChannel(Async)");
        }

        return deleteChannelCall(deleteChannelRequest, _callback);

    }

    /**
     * Removed a channel and its associated colour from the channel list.
     * Removed a channel and its associated colour from the channel list.
     * @param deleteChannelRequest Removed a channel and its associated colour from the channel list. (required)
     * @return AUTHChangePasswordDefaultResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public AUTHChangePasswordDefaultResponse deleteChannel(DeleteChannelRequest deleteChannelRequest) throws ApiException {
        ApiResponse<AUTHChangePasswordDefaultResponse> localVarResp = deleteChannelWithHttpInfo(deleteChannelRequest);
        return localVarResp.getData();
    }

    /**
     * Removed a channel and its associated colour from the channel list.
     * Removed a channel and its associated colour from the channel list.
     * @param deleteChannelRequest Removed a channel and its associated colour from the channel list. (required)
     * @return ApiResponse&lt;AUTHChangePasswordDefaultResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<AUTHChangePasswordDefaultResponse> deleteChannelWithHttpInfo(DeleteChannelRequest deleteChannelRequest) throws ApiException {
        okhttp3.Call localVarCall = deleteChannelValidateBeforeCall(deleteChannelRequest, null);
        Type localVarReturnType = new TypeToken<AUTHChangePasswordDefaultResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Removed a channel and its associated colour from the channel list. (asynchronously)
     * Removed a channel and its associated colour from the channel list.
     * @param deleteChannelRequest Removed a channel and its associated colour from the channel list. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call deleteChannelAsync(DeleteChannelRequest deleteChannelRequest, final ApiCallback<AUTHChangePasswordDefaultResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = deleteChannelValidateBeforeCall(deleteChannelRequest, _callback);
        Type localVarReturnType = new TypeToken<AUTHChangePasswordDefaultResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for deleteEventStream
     * @param deleteEventStreamRequest Removes an event stream from the system, optionally purging and deleting the corresponding queue in DDE.  Also can delete the underlying data store if the number of rows in the data store is less than the number provided (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call deleteEventStreamCall(DeleteEventStreamRequest deleteEventStreamRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = deleteEventStreamRequest;

        // create path and map variables
        String localVarPath = "/DeleteEventStream";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "TokenAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call deleteEventStreamValidateBeforeCall(DeleteEventStreamRequest deleteEventStreamRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'deleteEventStreamRequest' is set
        if (deleteEventStreamRequest == null) {
            throw new ApiException("Missing the required parameter 'deleteEventStreamRequest' when calling deleteEventStream(Async)");
        }

        return deleteEventStreamCall(deleteEventStreamRequest, _callback);

    }

    /**
     * Removes an event stream from the system, optionally purging and deleting the corresponding queue in DDE.  Also can delete the underlying data store if the number of rows in the data store is less than the number provided
     * Removes an event stream from the system, optionally purging and deleting the corresponding queue in DDE.  Also can delete the underlying data store if the number of rows in the data store is less than the number provided
     * @param deleteEventStreamRequest Removes an event stream from the system, optionally purging and deleting the corresponding queue in DDE.  Also can delete the underlying data store if the number of rows in the data store is less than the number provided (required)
     * @return AUTHChangePasswordDefaultResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public AUTHChangePasswordDefaultResponse deleteEventStream(DeleteEventStreamRequest deleteEventStreamRequest) throws ApiException {
        ApiResponse<AUTHChangePasswordDefaultResponse> localVarResp = deleteEventStreamWithHttpInfo(deleteEventStreamRequest);
        return localVarResp.getData();
    }

    /**
     * Removes an event stream from the system, optionally purging and deleting the corresponding queue in DDE.  Also can delete the underlying data store if the number of rows in the data store is less than the number provided
     * Removes an event stream from the system, optionally purging and deleting the corresponding queue in DDE.  Also can delete the underlying data store if the number of rows in the data store is less than the number provided
     * @param deleteEventStreamRequest Removes an event stream from the system, optionally purging and deleting the corresponding queue in DDE.  Also can delete the underlying data store if the number of rows in the data store is less than the number provided (required)
     * @return ApiResponse&lt;AUTHChangePasswordDefaultResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<AUTHChangePasswordDefaultResponse> deleteEventStreamWithHttpInfo(DeleteEventStreamRequest deleteEventStreamRequest) throws ApiException {
        okhttp3.Call localVarCall = deleteEventStreamValidateBeforeCall(deleteEventStreamRequest, null);
        Type localVarReturnType = new TypeToken<AUTHChangePasswordDefaultResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Removes an event stream from the system, optionally purging and deleting the corresponding queue in DDE.  Also can delete the underlying data store if the number of rows in the data store is less than the number provided (asynchronously)
     * Removes an event stream from the system, optionally purging and deleting the corresponding queue in DDE.  Also can delete the underlying data store if the number of rows in the data store is less than the number provided
     * @param deleteEventStreamRequest Removes an event stream from the system, optionally purging and deleting the corresponding queue in DDE.  Also can delete the underlying data store if the number of rows in the data store is less than the number provided (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call deleteEventStreamAsync(DeleteEventStreamRequest deleteEventStreamRequest, final ApiCallback<AUTHChangePasswordDefaultResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = deleteEventStreamValidateBeforeCall(deleteEventStreamRequest, _callback);
        Type localVarReturnType = new TypeToken<AUTHChangePasswordDefaultResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for deleteEventStreamCustomerColumns
     * @param deleteEventStreamCustomerColumnsRequest Mark for deletion the specified customer attribute columns for an @see(EventStream).             NOTE THAT THE ASSOCIATED ENGINE COLUMN AND DDE CACHE COLUMN WILL BE DELETED AND ANY DATA LOST PERMANENTLY.             Deletion of the column from Engine and the DDE cache is not synchronous so attempts to recreate the column may fail initially and require a different name to be specified.             Once marked for deletion the columns no longer contribute to the cap imposed by the max number of allowed columns. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call deleteEventStreamCustomerColumnsCall(DeleteEventStreamCustomerColumnsRequest deleteEventStreamCustomerColumnsRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = deleteEventStreamCustomerColumnsRequest;

        // create path and map variables
        String localVarPath = "/DeleteEventStreamCustomerColumns";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "TokenAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call deleteEventStreamCustomerColumnsValidateBeforeCall(DeleteEventStreamCustomerColumnsRequest deleteEventStreamCustomerColumnsRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'deleteEventStreamCustomerColumnsRequest' is set
        if (deleteEventStreamCustomerColumnsRequest == null) {
            throw new ApiException("Missing the required parameter 'deleteEventStreamCustomerColumnsRequest' when calling deleteEventStreamCustomerColumns(Async)");
        }

        return deleteEventStreamCustomerColumnsCall(deleteEventStreamCustomerColumnsRequest, _callback);

    }

    /**
     * Mark for deletion the specified customer attribute columns for an @see(EventStream).             NOTE THAT THE ASSOCIATED ENGINE COLUMN AND DDE CACHE COLUMN WILL BE DELETED AND ANY DATA LOST PERMANENTLY.             Deletion of the column from Engine and the DDE cache is not synchronous so attempts to recreate the column may fail initially and require a different name to be specified.             Once marked for deletion the columns no longer contribute to the cap imposed by the max number of allowed columns.
     * Mark for deletion the specified customer attribute columns for an @see(EventStream).             NOTE THAT THE ASSOCIATED ENGINE COLUMN AND DDE CACHE COLUMN WILL BE DELETED AND ANY DATA LOST PERMANENTLY.             Deletion of the column from Engine and the DDE cache is not synchronous so attempts to recreate the column may fail initially and require a different name to be specified.             Once marked for deletion the columns no longer contribute to the cap imposed by the max number of allowed columns.
     * @param deleteEventStreamCustomerColumnsRequest Mark for deletion the specified customer attribute columns for an @see(EventStream).             NOTE THAT THE ASSOCIATED ENGINE COLUMN AND DDE CACHE COLUMN WILL BE DELETED AND ANY DATA LOST PERMANENTLY.             Deletion of the column from Engine and the DDE cache is not synchronous so attempts to recreate the column may fail initially and require a different name to be specified.             Once marked for deletion the columns no longer contribute to the cap imposed by the max number of allowed columns. (required)
     * @return AUTHChangePasswordDefaultResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public AUTHChangePasswordDefaultResponse deleteEventStreamCustomerColumns(DeleteEventStreamCustomerColumnsRequest deleteEventStreamCustomerColumnsRequest) throws ApiException {
        ApiResponse<AUTHChangePasswordDefaultResponse> localVarResp = deleteEventStreamCustomerColumnsWithHttpInfo(deleteEventStreamCustomerColumnsRequest);
        return localVarResp.getData();
    }

    /**
     * Mark for deletion the specified customer attribute columns for an @see(EventStream).             NOTE THAT THE ASSOCIATED ENGINE COLUMN AND DDE CACHE COLUMN WILL BE DELETED AND ANY DATA LOST PERMANENTLY.             Deletion of the column from Engine and the DDE cache is not synchronous so attempts to recreate the column may fail initially and require a different name to be specified.             Once marked for deletion the columns no longer contribute to the cap imposed by the max number of allowed columns.
     * Mark for deletion the specified customer attribute columns for an @see(EventStream).             NOTE THAT THE ASSOCIATED ENGINE COLUMN AND DDE CACHE COLUMN WILL BE DELETED AND ANY DATA LOST PERMANENTLY.             Deletion of the column from Engine and the DDE cache is not synchronous so attempts to recreate the column may fail initially and require a different name to be specified.             Once marked for deletion the columns no longer contribute to the cap imposed by the max number of allowed columns.
     * @param deleteEventStreamCustomerColumnsRequest Mark for deletion the specified customer attribute columns for an @see(EventStream).             NOTE THAT THE ASSOCIATED ENGINE COLUMN AND DDE CACHE COLUMN WILL BE DELETED AND ANY DATA LOST PERMANENTLY.             Deletion of the column from Engine and the DDE cache is not synchronous so attempts to recreate the column may fail initially and require a different name to be specified.             Once marked for deletion the columns no longer contribute to the cap imposed by the max number of allowed columns. (required)
     * @return ApiResponse&lt;AUTHChangePasswordDefaultResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<AUTHChangePasswordDefaultResponse> deleteEventStreamCustomerColumnsWithHttpInfo(DeleteEventStreamCustomerColumnsRequest deleteEventStreamCustomerColumnsRequest) throws ApiException {
        okhttp3.Call localVarCall = deleteEventStreamCustomerColumnsValidateBeforeCall(deleteEventStreamCustomerColumnsRequest, null);
        Type localVarReturnType = new TypeToken<AUTHChangePasswordDefaultResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Mark for deletion the specified customer attribute columns for an @see(EventStream).             NOTE THAT THE ASSOCIATED ENGINE COLUMN AND DDE CACHE COLUMN WILL BE DELETED AND ANY DATA LOST PERMANENTLY.             Deletion of the column from Engine and the DDE cache is not synchronous so attempts to recreate the column may fail initially and require a different name to be specified.             Once marked for deletion the columns no longer contribute to the cap imposed by the max number of allowed columns. (asynchronously)
     * Mark for deletion the specified customer attribute columns for an @see(EventStream).             NOTE THAT THE ASSOCIATED ENGINE COLUMN AND DDE CACHE COLUMN WILL BE DELETED AND ANY DATA LOST PERMANENTLY.             Deletion of the column from Engine and the DDE cache is not synchronous so attempts to recreate the column may fail initially and require a different name to be specified.             Once marked for deletion the columns no longer contribute to the cap imposed by the max number of allowed columns.
     * @param deleteEventStreamCustomerColumnsRequest Mark for deletion the specified customer attribute columns for an @see(EventStream).             NOTE THAT THE ASSOCIATED ENGINE COLUMN AND DDE CACHE COLUMN WILL BE DELETED AND ANY DATA LOST PERMANENTLY.             Deletion of the column from Engine and the DDE cache is not synchronous so attempts to recreate the column may fail initially and require a different name to be specified.             Once marked for deletion the columns no longer contribute to the cap imposed by the max number of allowed columns. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call deleteEventStreamCustomerColumnsAsync(DeleteEventStreamCustomerColumnsRequest deleteEventStreamCustomerColumnsRequest, final ApiCallback<AUTHChangePasswordDefaultResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = deleteEventStreamCustomerColumnsValidateBeforeCall(deleteEventStreamCustomerColumnsRequest, _callback);
        Type localVarReturnType = new TypeToken<AUTHChangePasswordDefaultResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for deleteEventStreamCustomerColumnsFromGroup
     * @param deleteEventStreamCustomerColumnsFromGroupRequest Mark for deletion the specified customer attribute columns for all @see(EventStream)s in a group.             NOTE THAT THE ASSOCIATED ENGINE COLUMN AND DDE CACHE COLUMN WILL BE DELETED AND ANY DATA LOST PERMANENTLY.             Deletion of the column from Engine and the DDE cache is not synchronous so attempts to recreate the column may fail initially and require a different name to be specified.             Once marked for deletion the columns no longer contribute to the cap imposed by the max number of allowed columns. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call deleteEventStreamCustomerColumnsFromGroupCall(DeleteEventStreamCustomerColumnsFromGroupRequest deleteEventStreamCustomerColumnsFromGroupRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = deleteEventStreamCustomerColumnsFromGroupRequest;

        // create path and map variables
        String localVarPath = "/DeleteEventStreamCustomerColumnsFromGroup";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "TokenAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call deleteEventStreamCustomerColumnsFromGroupValidateBeforeCall(DeleteEventStreamCustomerColumnsFromGroupRequest deleteEventStreamCustomerColumnsFromGroupRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'deleteEventStreamCustomerColumnsFromGroupRequest' is set
        if (deleteEventStreamCustomerColumnsFromGroupRequest == null) {
            throw new ApiException("Missing the required parameter 'deleteEventStreamCustomerColumnsFromGroupRequest' when calling deleteEventStreamCustomerColumnsFromGroup(Async)");
        }

        return deleteEventStreamCustomerColumnsFromGroupCall(deleteEventStreamCustomerColumnsFromGroupRequest, _callback);

    }

    /**
     * Mark for deletion the specified customer attribute columns for all @see(EventStream)s in a group.             NOTE THAT THE ASSOCIATED ENGINE COLUMN AND DDE CACHE COLUMN WILL BE DELETED AND ANY DATA LOST PERMANENTLY.             Deletion of the column from Engine and the DDE cache is not synchronous so attempts to recreate the column may fail initially and require a different name to be specified.             Once marked for deletion the columns no longer contribute to the cap imposed by the max number of allowed columns.
     * Mark for deletion the specified customer attribute columns for all @see(EventStream)s in a group.             NOTE THAT THE ASSOCIATED ENGINE COLUMN AND DDE CACHE COLUMN WILL BE DELETED AND ANY DATA LOST PERMANENTLY.             Deletion of the column from Engine and the DDE cache is not synchronous so attempts to recreate the column may fail initially and require a different name to be specified.             Once marked for deletion the columns no longer contribute to the cap imposed by the max number of allowed columns.
     * @param deleteEventStreamCustomerColumnsFromGroupRequest Mark for deletion the specified customer attribute columns for all @see(EventStream)s in a group.             NOTE THAT THE ASSOCIATED ENGINE COLUMN AND DDE CACHE COLUMN WILL BE DELETED AND ANY DATA LOST PERMANENTLY.             Deletion of the column from Engine and the DDE cache is not synchronous so attempts to recreate the column may fail initially and require a different name to be specified.             Once marked for deletion the columns no longer contribute to the cap imposed by the max number of allowed columns. (required)
     * @return AUTHChangePasswordDefaultResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public AUTHChangePasswordDefaultResponse deleteEventStreamCustomerColumnsFromGroup(DeleteEventStreamCustomerColumnsFromGroupRequest deleteEventStreamCustomerColumnsFromGroupRequest) throws ApiException {
        ApiResponse<AUTHChangePasswordDefaultResponse> localVarResp = deleteEventStreamCustomerColumnsFromGroupWithHttpInfo(deleteEventStreamCustomerColumnsFromGroupRequest);
        return localVarResp.getData();
    }

    /**
     * Mark for deletion the specified customer attribute columns for all @see(EventStream)s in a group.             NOTE THAT THE ASSOCIATED ENGINE COLUMN AND DDE CACHE COLUMN WILL BE DELETED AND ANY DATA LOST PERMANENTLY.             Deletion of the column from Engine and the DDE cache is not synchronous so attempts to recreate the column may fail initially and require a different name to be specified.             Once marked for deletion the columns no longer contribute to the cap imposed by the max number of allowed columns.
     * Mark for deletion the specified customer attribute columns for all @see(EventStream)s in a group.             NOTE THAT THE ASSOCIATED ENGINE COLUMN AND DDE CACHE COLUMN WILL BE DELETED AND ANY DATA LOST PERMANENTLY.             Deletion of the column from Engine and the DDE cache is not synchronous so attempts to recreate the column may fail initially and require a different name to be specified.             Once marked for deletion the columns no longer contribute to the cap imposed by the max number of allowed columns.
     * @param deleteEventStreamCustomerColumnsFromGroupRequest Mark for deletion the specified customer attribute columns for all @see(EventStream)s in a group.             NOTE THAT THE ASSOCIATED ENGINE COLUMN AND DDE CACHE COLUMN WILL BE DELETED AND ANY DATA LOST PERMANENTLY.             Deletion of the column from Engine and the DDE cache is not synchronous so attempts to recreate the column may fail initially and require a different name to be specified.             Once marked for deletion the columns no longer contribute to the cap imposed by the max number of allowed columns. (required)
     * @return ApiResponse&lt;AUTHChangePasswordDefaultResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<AUTHChangePasswordDefaultResponse> deleteEventStreamCustomerColumnsFromGroupWithHttpInfo(DeleteEventStreamCustomerColumnsFromGroupRequest deleteEventStreamCustomerColumnsFromGroupRequest) throws ApiException {
        okhttp3.Call localVarCall = deleteEventStreamCustomerColumnsFromGroupValidateBeforeCall(deleteEventStreamCustomerColumnsFromGroupRequest, null);
        Type localVarReturnType = new TypeToken<AUTHChangePasswordDefaultResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Mark for deletion the specified customer attribute columns for all @see(EventStream)s in a group.             NOTE THAT THE ASSOCIATED ENGINE COLUMN AND DDE CACHE COLUMN WILL BE DELETED AND ANY DATA LOST PERMANENTLY.             Deletion of the column from Engine and the DDE cache is not synchronous so attempts to recreate the column may fail initially and require a different name to be specified.             Once marked for deletion the columns no longer contribute to the cap imposed by the max number of allowed columns. (asynchronously)
     * Mark for deletion the specified customer attribute columns for all @see(EventStream)s in a group.             NOTE THAT THE ASSOCIATED ENGINE COLUMN AND DDE CACHE COLUMN WILL BE DELETED AND ANY DATA LOST PERMANENTLY.             Deletion of the column from Engine and the DDE cache is not synchronous so attempts to recreate the column may fail initially and require a different name to be specified.             Once marked for deletion the columns no longer contribute to the cap imposed by the max number of allowed columns.
     * @param deleteEventStreamCustomerColumnsFromGroupRequest Mark for deletion the specified customer attribute columns for all @see(EventStream)s in a group.             NOTE THAT THE ASSOCIATED ENGINE COLUMN AND DDE CACHE COLUMN WILL BE DELETED AND ANY DATA LOST PERMANENTLY.             Deletion of the column from Engine and the DDE cache is not synchronous so attempts to recreate the column may fail initially and require a different name to be specified.             Once marked for deletion the columns no longer contribute to the cap imposed by the max number of allowed columns. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call deleteEventStreamCustomerColumnsFromGroupAsync(DeleteEventStreamCustomerColumnsFromGroupRequest deleteEventStreamCustomerColumnsFromGroupRequest, final ApiCallback<AUTHChangePasswordDefaultResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = deleteEventStreamCustomerColumnsFromGroupValidateBeforeCall(deleteEventStreamCustomerColumnsFromGroupRequest, _callback);
        Type localVarReturnType = new TypeToken<AUTHChangePasswordDefaultResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for deleteEventStreamGroup
     * @param deleteEventStreamGroupRequest Removes a group of event streams from the system, optionally purging and deleting the corresponding queues in DDE. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call deleteEventStreamGroupCall(DeleteEventStreamGroupRequest deleteEventStreamGroupRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = deleteEventStreamGroupRequest;

        // create path and map variables
        String localVarPath = "/DeleteEventStreamGroup";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "TokenAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call deleteEventStreamGroupValidateBeforeCall(DeleteEventStreamGroupRequest deleteEventStreamGroupRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'deleteEventStreamGroupRequest' is set
        if (deleteEventStreamGroupRequest == null) {
            throw new ApiException("Missing the required parameter 'deleteEventStreamGroupRequest' when calling deleteEventStreamGroup(Async)");
        }

        return deleteEventStreamGroupCall(deleteEventStreamGroupRequest, _callback);

    }

    /**
     * Removes a group of event streams from the system, optionally purging and deleting the corresponding queues in DDE.
     * Removes a group of event streams from the system, optionally purging and deleting the corresponding queues in DDE.
     * @param deleteEventStreamGroupRequest Removes a group of event streams from the system, optionally purging and deleting the corresponding queues in DDE. (required)
     * @return AUTHChangePasswordDefaultResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public AUTHChangePasswordDefaultResponse deleteEventStreamGroup(DeleteEventStreamGroupRequest deleteEventStreamGroupRequest) throws ApiException {
        ApiResponse<AUTHChangePasswordDefaultResponse> localVarResp = deleteEventStreamGroupWithHttpInfo(deleteEventStreamGroupRequest);
        return localVarResp.getData();
    }

    /**
     * Removes a group of event streams from the system, optionally purging and deleting the corresponding queues in DDE.
     * Removes a group of event streams from the system, optionally purging and deleting the corresponding queues in DDE.
     * @param deleteEventStreamGroupRequest Removes a group of event streams from the system, optionally purging and deleting the corresponding queues in DDE. (required)
     * @return ApiResponse&lt;AUTHChangePasswordDefaultResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<AUTHChangePasswordDefaultResponse> deleteEventStreamGroupWithHttpInfo(DeleteEventStreamGroupRequest deleteEventStreamGroupRequest) throws ApiException {
        okhttp3.Call localVarCall = deleteEventStreamGroupValidateBeforeCall(deleteEventStreamGroupRequest, null);
        Type localVarReturnType = new TypeToken<AUTHChangePasswordDefaultResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Removes a group of event streams from the system, optionally purging and deleting the corresponding queues in DDE. (asynchronously)
     * Removes a group of event streams from the system, optionally purging and deleting the corresponding queues in DDE.
     * @param deleteEventStreamGroupRequest Removes a group of event streams from the system, optionally purging and deleting the corresponding queues in DDE. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call deleteEventStreamGroupAsync(DeleteEventStreamGroupRequest deleteEventStreamGroupRequest, final ApiCallback<AUTHChangePasswordDefaultResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = deleteEventStreamGroupValidateBeforeCall(deleteEventStreamGroupRequest, _callback);
        Type localVarReturnType = new TypeToken<AUTHChangePasswordDefaultResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for deleteIdealisedJourney
     * @param deleteIdealisedJourneyRequest Delete Idealised Journey&#39;s (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call deleteIdealisedJourneyCall(DeleteIdealisedJourneyRequest deleteIdealisedJourneyRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = deleteIdealisedJourneyRequest;

        // create path and map variables
        String localVarPath = "/DeleteIdealisedJourney";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "TokenAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call deleteIdealisedJourneyValidateBeforeCall(DeleteIdealisedJourneyRequest deleteIdealisedJourneyRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'deleteIdealisedJourneyRequest' is set
        if (deleteIdealisedJourneyRequest == null) {
            throw new ApiException("Missing the required parameter 'deleteIdealisedJourneyRequest' when calling deleteIdealisedJourney(Async)");
        }

        return deleteIdealisedJourneyCall(deleteIdealisedJourneyRequest, _callback);

    }

    /**
     * Delete Idealised Journey&#39;s
     * Delete Idealised Journey&#39;s
     * @param deleteIdealisedJourneyRequest Delete Idealised Journey&#39;s (required)
     * @return AUTHChangePasswordDefaultResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public AUTHChangePasswordDefaultResponse deleteIdealisedJourney(DeleteIdealisedJourneyRequest deleteIdealisedJourneyRequest) throws ApiException {
        ApiResponse<AUTHChangePasswordDefaultResponse> localVarResp = deleteIdealisedJourneyWithHttpInfo(deleteIdealisedJourneyRequest);
        return localVarResp.getData();
    }

    /**
     * Delete Idealised Journey&#39;s
     * Delete Idealised Journey&#39;s
     * @param deleteIdealisedJourneyRequest Delete Idealised Journey&#39;s (required)
     * @return ApiResponse&lt;AUTHChangePasswordDefaultResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<AUTHChangePasswordDefaultResponse> deleteIdealisedJourneyWithHttpInfo(DeleteIdealisedJourneyRequest deleteIdealisedJourneyRequest) throws ApiException {
        okhttp3.Call localVarCall = deleteIdealisedJourneyValidateBeforeCall(deleteIdealisedJourneyRequest, null);
        Type localVarReturnType = new TypeToken<AUTHChangePasswordDefaultResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Delete Idealised Journey&#39;s (asynchronously)
     * Delete Idealised Journey&#39;s
     * @param deleteIdealisedJourneyRequest Delete Idealised Journey&#39;s (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call deleteIdealisedJourneyAsync(DeleteIdealisedJourneyRequest deleteIdealisedJourneyRequest, final ApiCallback<AUTHChangePasswordDefaultResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = deleteIdealisedJourneyValidateBeforeCall(deleteIdealisedJourneyRequest, _callback);
        Type localVarReturnType = new TypeToken<AUTHChangePasswordDefaultResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for deleteSankeyFavourites
     * @param deleteSankeyFavouritesRequest Delete a sankey favourite (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call deleteSankeyFavouritesCall(DeleteSankeyFavouritesRequest deleteSankeyFavouritesRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = deleteSankeyFavouritesRequest;

        // create path and map variables
        String localVarPath = "/DeleteSankeyFavourites";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "TokenAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call deleteSankeyFavouritesValidateBeforeCall(DeleteSankeyFavouritesRequest deleteSankeyFavouritesRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'deleteSankeyFavouritesRequest' is set
        if (deleteSankeyFavouritesRequest == null) {
            throw new ApiException("Missing the required parameter 'deleteSankeyFavouritesRequest' when calling deleteSankeyFavourites(Async)");
        }

        return deleteSankeyFavouritesCall(deleteSankeyFavouritesRequest, _callback);

    }

    /**
     * Delete a sankey favourite
     * Delete a sankey favourite
     * @param deleteSankeyFavouritesRequest Delete a sankey favourite (required)
     * @return AUTHChangePasswordDefaultResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public AUTHChangePasswordDefaultResponse deleteSankeyFavourites(DeleteSankeyFavouritesRequest deleteSankeyFavouritesRequest) throws ApiException {
        ApiResponse<AUTHChangePasswordDefaultResponse> localVarResp = deleteSankeyFavouritesWithHttpInfo(deleteSankeyFavouritesRequest);
        return localVarResp.getData();
    }

    /**
     * Delete a sankey favourite
     * Delete a sankey favourite
     * @param deleteSankeyFavouritesRequest Delete a sankey favourite (required)
     * @return ApiResponse&lt;AUTHChangePasswordDefaultResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<AUTHChangePasswordDefaultResponse> deleteSankeyFavouritesWithHttpInfo(DeleteSankeyFavouritesRequest deleteSankeyFavouritesRequest) throws ApiException {
        okhttp3.Call localVarCall = deleteSankeyFavouritesValidateBeforeCall(deleteSankeyFavouritesRequest, null);
        Type localVarReturnType = new TypeToken<AUTHChangePasswordDefaultResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Delete a sankey favourite (asynchronously)
     * Delete a sankey favourite
     * @param deleteSankeyFavouritesRequest Delete a sankey favourite (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call deleteSankeyFavouritesAsync(DeleteSankeyFavouritesRequest deleteSankeyFavouritesRequest, final ApiCallback<AUTHChangePasswordDefaultResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = deleteSankeyFavouritesValidateBeforeCall(deleteSankeyFavouritesRequest, _callback);
        Type localVarReturnType = new TypeToken<AUTHChangePasswordDefaultResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for deleteVisualisationFavourites
     * @param deleteVisualisationFavouritesRequest Delete Visualisation favourite(s) (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call deleteVisualisationFavouritesCall(DeleteVisualisationFavouritesRequest deleteVisualisationFavouritesRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = deleteVisualisationFavouritesRequest;

        // create path and map variables
        String localVarPath = "/DeleteVisualisationFavourites";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "TokenAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call deleteVisualisationFavouritesValidateBeforeCall(DeleteVisualisationFavouritesRequest deleteVisualisationFavouritesRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'deleteVisualisationFavouritesRequest' is set
        if (deleteVisualisationFavouritesRequest == null) {
            throw new ApiException("Missing the required parameter 'deleteVisualisationFavouritesRequest' when calling deleteVisualisationFavourites(Async)");
        }

        return deleteVisualisationFavouritesCall(deleteVisualisationFavouritesRequest, _callback);

    }

    /**
     * Delete Visualisation favourite(s)
     * Delete Visualisation favourite(s)
     * @param deleteVisualisationFavouritesRequest Delete Visualisation favourite(s) (required)
     * @return AUTHChangePasswordDefaultResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public AUTHChangePasswordDefaultResponse deleteVisualisationFavourites(DeleteVisualisationFavouritesRequest deleteVisualisationFavouritesRequest) throws ApiException {
        ApiResponse<AUTHChangePasswordDefaultResponse> localVarResp = deleteVisualisationFavouritesWithHttpInfo(deleteVisualisationFavouritesRequest);
        return localVarResp.getData();
    }

    /**
     * Delete Visualisation favourite(s)
     * Delete Visualisation favourite(s)
     * @param deleteVisualisationFavouritesRequest Delete Visualisation favourite(s) (required)
     * @return ApiResponse&lt;AUTHChangePasswordDefaultResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<AUTHChangePasswordDefaultResponse> deleteVisualisationFavouritesWithHttpInfo(DeleteVisualisationFavouritesRequest deleteVisualisationFavouritesRequest) throws ApiException {
        okhttp3.Call localVarCall = deleteVisualisationFavouritesValidateBeforeCall(deleteVisualisationFavouritesRequest, null);
        Type localVarReturnType = new TypeToken<AUTHChangePasswordDefaultResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Delete Visualisation favourite(s) (asynchronously)
     * Delete Visualisation favourite(s)
     * @param deleteVisualisationFavouritesRequest Delete Visualisation favourite(s) (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call deleteVisualisationFavouritesAsync(DeleteVisualisationFavouritesRequest deleteVisualisationFavouritesRequest, final ApiCallback<AUTHChangePasswordDefaultResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = deleteVisualisationFavouritesValidateBeforeCall(deleteVisualisationFavouritesRequest, _callback);
        Type localVarReturnType = new TypeToken<AUTHChangePasswordDefaultResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for exportEventStreamInteraction
     * @param exportEventStreamInteractionRequest Exports the domain of a particular node to return a sample of the CXID (VisitorId) values.             To get the results for \&quot;other\&quot; events pass all displayed events and set &#39;IncludeMatchedEvents&#39; to False. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call exportEventStreamInteractionCall(ExportEventStreamInteractionRequest exportEventStreamInteractionRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = exportEventStreamInteractionRequest;

        // create path and map variables
        String localVarPath = "/ExportEventStreamInteraction";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "TokenAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call exportEventStreamInteractionValidateBeforeCall(ExportEventStreamInteractionRequest exportEventStreamInteractionRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'exportEventStreamInteractionRequest' is set
        if (exportEventStreamInteractionRequest == null) {
            throw new ApiException("Missing the required parameter 'exportEventStreamInteractionRequest' when calling exportEventStreamInteraction(Async)");
        }

        return exportEventStreamInteractionCall(exportEventStreamInteractionRequest, _callback);

    }

    /**
     * Exports the domain of a particular node to return a sample of the CXID (VisitorId) values.             To get the results for \&quot;other\&quot; events pass all displayed events and set &#39;IncludeMatchedEvents&#39; to False.
     * Exports the domain of a particular node to return a sample of the CXID (VisitorId) values.             To get the results for \&quot;other\&quot; events pass all displayed events and set &#39;IncludeMatchedEvents&#39; to False.
     * @param exportEventStreamInteractionRequest Exports the domain of a particular node to return a sample of the CXID (VisitorId) values.             To get the results for \&quot;other\&quot; events pass all displayed events and set &#39;IncludeMatchedEvents&#39; to False. (required)
     * @return File
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public File exportEventStreamInteraction(ExportEventStreamInteractionRequest exportEventStreamInteractionRequest) throws ApiException {
        ApiResponse<File> localVarResp = exportEventStreamInteractionWithHttpInfo(exportEventStreamInteractionRequest);
        return localVarResp.getData();
    }

    /**
     * Exports the domain of a particular node to return a sample of the CXID (VisitorId) values.             To get the results for \&quot;other\&quot; events pass all displayed events and set &#39;IncludeMatchedEvents&#39; to False.
     * Exports the domain of a particular node to return a sample of the CXID (VisitorId) values.             To get the results for \&quot;other\&quot; events pass all displayed events and set &#39;IncludeMatchedEvents&#39; to False.
     * @param exportEventStreamInteractionRequest Exports the domain of a particular node to return a sample of the CXID (VisitorId) values.             To get the results for \&quot;other\&quot; events pass all displayed events and set &#39;IncludeMatchedEvents&#39; to False. (required)
     * @return ApiResponse&lt;File&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<File> exportEventStreamInteractionWithHttpInfo(ExportEventStreamInteractionRequest exportEventStreamInteractionRequest) throws ApiException {
        okhttp3.Call localVarCall = exportEventStreamInteractionValidateBeforeCall(exportEventStreamInteractionRequest, null);
        Type localVarReturnType = new TypeToken<File>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Exports the domain of a particular node to return a sample of the CXID (VisitorId) values.             To get the results for \&quot;other\&quot; events pass all displayed events and set &#39;IncludeMatchedEvents&#39; to False. (asynchronously)
     * Exports the domain of a particular node to return a sample of the CXID (VisitorId) values.             To get the results for \&quot;other\&quot; events pass all displayed events and set &#39;IncludeMatchedEvents&#39; to False.
     * @param exportEventStreamInteractionRequest Exports the domain of a particular node to return a sample of the CXID (VisitorId) values.             To get the results for \&quot;other\&quot; events pass all displayed events and set &#39;IncludeMatchedEvents&#39; to False. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call exportEventStreamInteractionAsync(ExportEventStreamInteractionRequest exportEventStreamInteractionRequest, final ApiCallback<File> _callback) throws ApiException {

        okhttp3.Call localVarCall = exportEventStreamInteractionValidateBeforeCall(exportEventStreamInteractionRequest, _callback);
        Type localVarReturnType = new TypeToken<File>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getChannels
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getChannelsCall(final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/GetChannels";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "TokenAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getChannelsValidateBeforeCall(final ApiCallback _callback) throws ApiException {
        return getChannelsCall(_callback);

    }

    /**
     * Return back a list of channels and their associated colours
     * Return back a list of channels and their associated colours
     * @return GetChannelsDefaultResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public GetChannelsDefaultResponse getChannels() throws ApiException {
        ApiResponse<GetChannelsDefaultResponse> localVarResp = getChannelsWithHttpInfo();
        return localVarResp.getData();
    }

    /**
     * Return back a list of channels and their associated colours
     * Return back a list of channels and their associated colours
     * @return ApiResponse&lt;GetChannelsDefaultResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<GetChannelsDefaultResponse> getChannelsWithHttpInfo() throws ApiException {
        okhttp3.Call localVarCall = getChannelsValidateBeforeCall(null);
        Type localVarReturnType = new TypeToken<GetChannelsDefaultResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Return back a list of channels and their associated colours (asynchronously)
     * Return back a list of channels and their associated colours
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getChannelsAsync(final ApiCallback<GetChannelsDefaultResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = getChannelsValidateBeforeCall(_callback);
        Type localVarReturnType = new TypeToken<GetChannelsDefaultResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getEventRecords
     * @param getEventRecordsRequest Obtain the event records from an event stream table that match the specified key (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getEventRecordsCall(GetEventRecordsRequest getEventRecordsRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = getEventRecordsRequest;

        // create path and map variables
        String localVarPath = "/GetEventRecords";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "TokenAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getEventRecordsValidateBeforeCall(GetEventRecordsRequest getEventRecordsRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'getEventRecordsRequest' is set
        if (getEventRecordsRequest == null) {
            throw new ApiException("Missing the required parameter 'getEventRecordsRequest' when calling getEventRecords(Async)");
        }

        return getEventRecordsCall(getEventRecordsRequest, _callback);

    }

    /**
     * Obtain the event records from an event stream table that match the specified key
     * Obtain the event records from an event stream table that match the specified key
     * @param getEventRecordsRequest Obtain the event records from an event stream table that match the specified key (required)
     * @return GetEventRecordsDefaultResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public GetEventRecordsDefaultResponse getEventRecords(GetEventRecordsRequest getEventRecordsRequest) throws ApiException {
        ApiResponse<GetEventRecordsDefaultResponse> localVarResp = getEventRecordsWithHttpInfo(getEventRecordsRequest);
        return localVarResp.getData();
    }

    /**
     * Obtain the event records from an event stream table that match the specified key
     * Obtain the event records from an event stream table that match the specified key
     * @param getEventRecordsRequest Obtain the event records from an event stream table that match the specified key (required)
     * @return ApiResponse&lt;GetEventRecordsDefaultResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<GetEventRecordsDefaultResponse> getEventRecordsWithHttpInfo(GetEventRecordsRequest getEventRecordsRequest) throws ApiException {
        okhttp3.Call localVarCall = getEventRecordsValidateBeforeCall(getEventRecordsRequest, null);
        Type localVarReturnType = new TypeToken<GetEventRecordsDefaultResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Obtain the event records from an event stream table that match the specified key (asynchronously)
     * Obtain the event records from an event stream table that match the specified key
     * @param getEventRecordsRequest Obtain the event records from an event stream table that match the specified key (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getEventRecordsAsync(GetEventRecordsRequest getEventRecordsRequest, final ApiCallback<GetEventRecordsDefaultResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = getEventRecordsValidateBeforeCall(getEventRecordsRequest, _callback);
        Type localVarReturnType = new TypeToken<GetEventRecordsDefaultResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getEventStream
     * @param getEventStreamRequest Return back the full details of an @see(EventStream).  Ids are available from @see(GetEventStreams) (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getEventStreamCall(GetEventStreamRequest getEventStreamRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = getEventStreamRequest;

        // create path and map variables
        String localVarPath = "/GetEventStream";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "TokenAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getEventStreamValidateBeforeCall(GetEventStreamRequest getEventStreamRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'getEventStreamRequest' is set
        if (getEventStreamRequest == null) {
            throw new ApiException("Missing the required parameter 'getEventStreamRequest' when calling getEventStream(Async)");
        }

        return getEventStreamCall(getEventStreamRequest, _callback);

    }

    /**
     * Return back the full details of an @see(EventStream).  Ids are available from @see(GetEventStreams)
     * Return back the full details of an @see(EventStream).  Ids are available from @see(GetEventStreams)
     * @param getEventStreamRequest Return back the full details of an @see(EventStream).  Ids are available from @see(GetEventStreams) (required)
     * @return GetEventStreamDefaultResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public GetEventStreamDefaultResponse getEventStream(GetEventStreamRequest getEventStreamRequest) throws ApiException {
        ApiResponse<GetEventStreamDefaultResponse> localVarResp = getEventStreamWithHttpInfo(getEventStreamRequest);
        return localVarResp.getData();
    }

    /**
     * Return back the full details of an @see(EventStream).  Ids are available from @see(GetEventStreams)
     * Return back the full details of an @see(EventStream).  Ids are available from @see(GetEventStreams)
     * @param getEventStreamRequest Return back the full details of an @see(EventStream).  Ids are available from @see(GetEventStreams) (required)
     * @return ApiResponse&lt;GetEventStreamDefaultResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<GetEventStreamDefaultResponse> getEventStreamWithHttpInfo(GetEventStreamRequest getEventStreamRequest) throws ApiException {
        okhttp3.Call localVarCall = getEventStreamValidateBeforeCall(getEventStreamRequest, null);
        Type localVarReturnType = new TypeToken<GetEventStreamDefaultResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Return back the full details of an @see(EventStream).  Ids are available from @see(GetEventStreams) (asynchronously)
     * Return back the full details of an @see(EventStream).  Ids are available from @see(GetEventStreams)
     * @param getEventStreamRequest Return back the full details of an @see(EventStream).  Ids are available from @see(GetEventStreams) (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getEventStreamAsync(GetEventStreamRequest getEventStreamRequest, final ApiCallback<GetEventStreamDefaultResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = getEventStreamValidateBeforeCall(getEventStreamRequest, _callback);
        Type localVarReturnType = new TypeToken<GetEventStreamDefaultResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getEventStreamAggregates
     * @param getEventStreamAggregatesRequest Get aggregate stats for an Event Stream.              Currently only supported for JD snapshots (simply because traditional sankey snapshots won&#39;t have the financial columns yet) (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getEventStreamAggregatesCall(GetEventStreamAggregatesRequest getEventStreamAggregatesRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = getEventStreamAggregatesRequest;

        // create path and map variables
        String localVarPath = "/GetEventStreamAggregates";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "TokenAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getEventStreamAggregatesValidateBeforeCall(GetEventStreamAggregatesRequest getEventStreamAggregatesRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'getEventStreamAggregatesRequest' is set
        if (getEventStreamAggregatesRequest == null) {
            throw new ApiException("Missing the required parameter 'getEventStreamAggregatesRequest' when calling getEventStreamAggregates(Async)");
        }

        return getEventStreamAggregatesCall(getEventStreamAggregatesRequest, _callback);

    }

    /**
     * Get aggregate stats for an Event Stream.              Currently only supported for JD snapshots (simply because traditional sankey snapshots won&#39;t have the financial columns yet)
     * Get aggregate stats for an Event Stream.              Currently only supported for JD snapshots (simply because traditional sankey snapshots won&#39;t have the financial columns yet)
     * @param getEventStreamAggregatesRequest Get aggregate stats for an Event Stream.              Currently only supported for JD snapshots (simply because traditional sankey snapshots won&#39;t have the financial columns yet) (required)
     * @return GetEventRecordsDefaultResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public GetEventRecordsDefaultResponse getEventStreamAggregates(GetEventStreamAggregatesRequest getEventStreamAggregatesRequest) throws ApiException {
        ApiResponse<GetEventRecordsDefaultResponse> localVarResp = getEventStreamAggregatesWithHttpInfo(getEventStreamAggregatesRequest);
        return localVarResp.getData();
    }

    /**
     * Get aggregate stats for an Event Stream.              Currently only supported for JD snapshots (simply because traditional sankey snapshots won&#39;t have the financial columns yet)
     * Get aggregate stats for an Event Stream.              Currently only supported for JD snapshots (simply because traditional sankey snapshots won&#39;t have the financial columns yet)
     * @param getEventStreamAggregatesRequest Get aggregate stats for an Event Stream.              Currently only supported for JD snapshots (simply because traditional sankey snapshots won&#39;t have the financial columns yet) (required)
     * @return ApiResponse&lt;GetEventRecordsDefaultResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<GetEventRecordsDefaultResponse> getEventStreamAggregatesWithHttpInfo(GetEventStreamAggregatesRequest getEventStreamAggregatesRequest) throws ApiException {
        okhttp3.Call localVarCall = getEventStreamAggregatesValidateBeforeCall(getEventStreamAggregatesRequest, null);
        Type localVarReturnType = new TypeToken<GetEventRecordsDefaultResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get aggregate stats for an Event Stream.              Currently only supported for JD snapshots (simply because traditional sankey snapshots won&#39;t have the financial columns yet) (asynchronously)
     * Get aggregate stats for an Event Stream.              Currently only supported for JD snapshots (simply because traditional sankey snapshots won&#39;t have the financial columns yet)
     * @param getEventStreamAggregatesRequest Get aggregate stats for an Event Stream.              Currently only supported for JD snapshots (simply because traditional sankey snapshots won&#39;t have the financial columns yet) (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getEventStreamAggregatesAsync(GetEventStreamAggregatesRequest getEventStreamAggregatesRequest, final ApiCallback<GetEventRecordsDefaultResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = getEventStreamAggregatesValidateBeforeCall(getEventStreamAggregatesRequest, _callback);
        Type localVarReturnType = new TypeToken<GetEventRecordsDefaultResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getEventStreamChannels
     * @param getEventStreamChannelsRequest Requests a list of the channels which the event stream has received.  Use this list to create channel colour mappings @see(CreateChannel).  Use @see(GetEventStreams) for a list of the available @see(EventStream)s (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getEventStreamChannelsCall(GetEventStreamChannelsRequest getEventStreamChannelsRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = getEventStreamChannelsRequest;

        // create path and map variables
        String localVarPath = "/GetEventStreamChannels";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "TokenAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getEventStreamChannelsValidateBeforeCall(GetEventStreamChannelsRequest getEventStreamChannelsRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'getEventStreamChannelsRequest' is set
        if (getEventStreamChannelsRequest == null) {
            throw new ApiException("Missing the required parameter 'getEventStreamChannelsRequest' when calling getEventStreamChannels(Async)");
        }

        return getEventStreamChannelsCall(getEventStreamChannelsRequest, _callback);

    }

    /**
     * Requests a list of the channels which the event stream has received.  Use this list to create channel colour mappings @see(CreateChannel).  Use @see(GetEventStreams) for a list of the available @see(EventStream)s
     * Requests a list of the channels which the event stream has received.  Use this list to create channel colour mappings @see(CreateChannel).  Use @see(GetEventStreams) for a list of the available @see(EventStream)s
     * @param getEventStreamChannelsRequest Requests a list of the channels which the event stream has received.  Use this list to create channel colour mappings @see(CreateChannel).  Use @see(GetEventStreams) for a list of the available @see(EventStream)s (required)
     * @return GetDataSourceUsersDefaultResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public GetDataSourceUsersDefaultResponse getEventStreamChannels(GetEventStreamChannelsRequest getEventStreamChannelsRequest) throws ApiException {
        ApiResponse<GetDataSourceUsersDefaultResponse> localVarResp = getEventStreamChannelsWithHttpInfo(getEventStreamChannelsRequest);
        return localVarResp.getData();
    }

    /**
     * Requests a list of the channels which the event stream has received.  Use this list to create channel colour mappings @see(CreateChannel).  Use @see(GetEventStreams) for a list of the available @see(EventStream)s
     * Requests a list of the channels which the event stream has received.  Use this list to create channel colour mappings @see(CreateChannel).  Use @see(GetEventStreams) for a list of the available @see(EventStream)s
     * @param getEventStreamChannelsRequest Requests a list of the channels which the event stream has received.  Use this list to create channel colour mappings @see(CreateChannel).  Use @see(GetEventStreams) for a list of the available @see(EventStream)s (required)
     * @return ApiResponse&lt;GetDataSourceUsersDefaultResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<GetDataSourceUsersDefaultResponse> getEventStreamChannelsWithHttpInfo(GetEventStreamChannelsRequest getEventStreamChannelsRequest) throws ApiException {
        okhttp3.Call localVarCall = getEventStreamChannelsValidateBeforeCall(getEventStreamChannelsRequest, null);
        Type localVarReturnType = new TypeToken<GetDataSourceUsersDefaultResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Requests a list of the channels which the event stream has received.  Use this list to create channel colour mappings @see(CreateChannel).  Use @see(GetEventStreams) for a list of the available @see(EventStream)s (asynchronously)
     * Requests a list of the channels which the event stream has received.  Use this list to create channel colour mappings @see(CreateChannel).  Use @see(GetEventStreams) for a list of the available @see(EventStream)s
     * @param getEventStreamChannelsRequest Requests a list of the channels which the event stream has received.  Use this list to create channel colour mappings @see(CreateChannel).  Use @see(GetEventStreams) for a list of the available @see(EventStream)s (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getEventStreamChannelsAsync(GetEventStreamChannelsRequest getEventStreamChannelsRequest, final ApiCallback<GetDataSourceUsersDefaultResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = getEventStreamChannelsValidateBeforeCall(getEventStreamChannelsRequest, _callback);
        Type localVarReturnType = new TypeToken<GetDataSourceUsersDefaultResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getEventStreamDecodeMappings
     * @param getEventStreamDecodeMappingsRequest Given an event stream this API will take an event stream column, sample the data using the specified dates, apply any published transform and then return a cursored list of the labels taking account any decodes that may have been specified             Note that this API does not use any published decode information, if a decode list is to be applied then it should be specified explicitly (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getEventStreamDecodeMappingsCall(GetEventStreamDecodeMappingsRequest getEventStreamDecodeMappingsRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = getEventStreamDecodeMappingsRequest;

        // create path and map variables
        String localVarPath = "/GetEventStreamDecodeMappings";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "TokenAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getEventStreamDecodeMappingsValidateBeforeCall(GetEventStreamDecodeMappingsRequest getEventStreamDecodeMappingsRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'getEventStreamDecodeMappingsRequest' is set
        if (getEventStreamDecodeMappingsRequest == null) {
            throw new ApiException("Missing the required parameter 'getEventStreamDecodeMappingsRequest' when calling getEventStreamDecodeMappings(Async)");
        }

        return getEventStreamDecodeMappingsCall(getEventStreamDecodeMappingsRequest, _callback);

    }

    /**
     * Given an event stream this API will take an event stream column, sample the data using the specified dates, apply any published transform and then return a cursored list of the labels taking account any decodes that may have been specified             Note that this API does not use any published decode information, if a decode list is to be applied then it should be specified explicitly
     * Given an event stream this API will take an event stream column, sample the data using the specified dates, apply any published transform and then return a cursored list of the labels taking account any decodes that may have been specified             Note that this API does not use any published decode information, if a decode list is to be applied then it should be specified explicitly
     * @param getEventStreamDecodeMappingsRequest Given an event stream this API will take an event stream column, sample the data using the specified dates, apply any published transform and then return a cursored list of the labels taking account any decodes that may have been specified             Note that this API does not use any published decode information, if a decode list is to be applied then it should be specified explicitly (required)
     * @return GetEventStreamDecodeMappingsDefaultResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public GetEventStreamDecodeMappingsDefaultResponse getEventStreamDecodeMappings(GetEventStreamDecodeMappingsRequest getEventStreamDecodeMappingsRequest) throws ApiException {
        ApiResponse<GetEventStreamDecodeMappingsDefaultResponse> localVarResp = getEventStreamDecodeMappingsWithHttpInfo(getEventStreamDecodeMappingsRequest);
        return localVarResp.getData();
    }

    /**
     * Given an event stream this API will take an event stream column, sample the data using the specified dates, apply any published transform and then return a cursored list of the labels taking account any decodes that may have been specified             Note that this API does not use any published decode information, if a decode list is to be applied then it should be specified explicitly
     * Given an event stream this API will take an event stream column, sample the data using the specified dates, apply any published transform and then return a cursored list of the labels taking account any decodes that may have been specified             Note that this API does not use any published decode information, if a decode list is to be applied then it should be specified explicitly
     * @param getEventStreamDecodeMappingsRequest Given an event stream this API will take an event stream column, sample the data using the specified dates, apply any published transform and then return a cursored list of the labels taking account any decodes that may have been specified             Note that this API does not use any published decode information, if a decode list is to be applied then it should be specified explicitly (required)
     * @return ApiResponse&lt;GetEventStreamDecodeMappingsDefaultResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<GetEventStreamDecodeMappingsDefaultResponse> getEventStreamDecodeMappingsWithHttpInfo(GetEventStreamDecodeMappingsRequest getEventStreamDecodeMappingsRequest) throws ApiException {
        okhttp3.Call localVarCall = getEventStreamDecodeMappingsValidateBeforeCall(getEventStreamDecodeMappingsRequest, null);
        Type localVarReturnType = new TypeToken<GetEventStreamDecodeMappingsDefaultResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Given an event stream this API will take an event stream column, sample the data using the specified dates, apply any published transform and then return a cursored list of the labels taking account any decodes that may have been specified             Note that this API does not use any published decode information, if a decode list is to be applied then it should be specified explicitly (asynchronously)
     * Given an event stream this API will take an event stream column, sample the data using the specified dates, apply any published transform and then return a cursored list of the labels taking account any decodes that may have been specified             Note that this API does not use any published decode information, if a decode list is to be applied then it should be specified explicitly
     * @param getEventStreamDecodeMappingsRequest Given an event stream this API will take an event stream column, sample the data using the specified dates, apply any published transform and then return a cursored list of the labels taking account any decodes that may have been specified             Note that this API does not use any published decode information, if a decode list is to be applied then it should be specified explicitly (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getEventStreamDecodeMappingsAsync(GetEventStreamDecodeMappingsRequest getEventStreamDecodeMappingsRequest, final ApiCallback<GetEventStreamDecodeMappingsDefaultResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = getEventStreamDecodeMappingsValidateBeforeCall(getEventStreamDecodeMappingsRequest, _callback);
        Type localVarReturnType = new TypeToken<GetEventStreamDecodeMappingsDefaultResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getEventStreamDecodeTargetDiscretes
     * @param getEventStreamDecodeTargetDiscretesRequest Given an event stream this API will take an event stream column, sample the data using the specified dates, apply any published transform and then return a list of all the currently configured decode targets along with any counts             If a target does not appear in the sampled data it will be returned with a count of zero so it can be optionally filtered out of any picklist (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getEventStreamDecodeTargetDiscretesCall(GetEventStreamDecodeTargetDiscretesRequest getEventStreamDecodeTargetDiscretesRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = getEventStreamDecodeTargetDiscretesRequest;

        // create path and map variables
        String localVarPath = "/GetEventStreamDecodeTargetDiscretes";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "TokenAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getEventStreamDecodeTargetDiscretesValidateBeforeCall(GetEventStreamDecodeTargetDiscretesRequest getEventStreamDecodeTargetDiscretesRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'getEventStreamDecodeTargetDiscretesRequest' is set
        if (getEventStreamDecodeTargetDiscretesRequest == null) {
            throw new ApiException("Missing the required parameter 'getEventStreamDecodeTargetDiscretesRequest' when calling getEventStreamDecodeTargetDiscretes(Async)");
        }

        return getEventStreamDecodeTargetDiscretesCall(getEventStreamDecodeTargetDiscretesRequest, _callback);

    }

    /**
     * Given an event stream this API will take an event stream column, sample the data using the specified dates, apply any published transform and then return a list of all the currently configured decode targets along with any counts             If a target does not appear in the sampled data it will be returned with a count of zero so it can be optionally filtered out of any picklist
     * Given an event stream this API will take an event stream column, sample the data using the specified dates, apply any published transform and then return a list of all the currently configured decode targets along with any counts             If a target does not appear in the sampled data it will be returned with a count of zero so it can be optionally filtered out of any picklist
     * @param getEventStreamDecodeTargetDiscretesRequest Given an event stream this API will take an event stream column, sample the data using the specified dates, apply any published transform and then return a list of all the currently configured decode targets along with any counts             If a target does not appear in the sampled data it will be returned with a count of zero so it can be optionally filtered out of any picklist (required)
     * @return GetEventStreamDecodeTargetDiscretesDefaultResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public GetEventStreamDecodeTargetDiscretesDefaultResponse getEventStreamDecodeTargetDiscretes(GetEventStreamDecodeTargetDiscretesRequest getEventStreamDecodeTargetDiscretesRequest) throws ApiException {
        ApiResponse<GetEventStreamDecodeTargetDiscretesDefaultResponse> localVarResp = getEventStreamDecodeTargetDiscretesWithHttpInfo(getEventStreamDecodeTargetDiscretesRequest);
        return localVarResp.getData();
    }

    /**
     * Given an event stream this API will take an event stream column, sample the data using the specified dates, apply any published transform and then return a list of all the currently configured decode targets along with any counts             If a target does not appear in the sampled data it will be returned with a count of zero so it can be optionally filtered out of any picklist
     * Given an event stream this API will take an event stream column, sample the data using the specified dates, apply any published transform and then return a list of all the currently configured decode targets along with any counts             If a target does not appear in the sampled data it will be returned with a count of zero so it can be optionally filtered out of any picklist
     * @param getEventStreamDecodeTargetDiscretesRequest Given an event stream this API will take an event stream column, sample the data using the specified dates, apply any published transform and then return a list of all the currently configured decode targets along with any counts             If a target does not appear in the sampled data it will be returned with a count of zero so it can be optionally filtered out of any picklist (required)
     * @return ApiResponse&lt;GetEventStreamDecodeTargetDiscretesDefaultResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<GetEventStreamDecodeTargetDiscretesDefaultResponse> getEventStreamDecodeTargetDiscretesWithHttpInfo(GetEventStreamDecodeTargetDiscretesRequest getEventStreamDecodeTargetDiscretesRequest) throws ApiException {
        okhttp3.Call localVarCall = getEventStreamDecodeTargetDiscretesValidateBeforeCall(getEventStreamDecodeTargetDiscretesRequest, null);
        Type localVarReturnType = new TypeToken<GetEventStreamDecodeTargetDiscretesDefaultResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Given an event stream this API will take an event stream column, sample the data using the specified dates, apply any published transform and then return a list of all the currently configured decode targets along with any counts             If a target does not appear in the sampled data it will be returned with a count of zero so it can be optionally filtered out of any picklist (asynchronously)
     * Given an event stream this API will take an event stream column, sample the data using the specified dates, apply any published transform and then return a list of all the currently configured decode targets along with any counts             If a target does not appear in the sampled data it will be returned with a count of zero so it can be optionally filtered out of any picklist
     * @param getEventStreamDecodeTargetDiscretesRequest Given an event stream this API will take an event stream column, sample the data using the specified dates, apply any published transform and then return a list of all the currently configured decode targets along with any counts             If a target does not appear in the sampled data it will be returned with a count of zero so it can be optionally filtered out of any picklist (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getEventStreamDecodeTargetDiscretesAsync(GetEventStreamDecodeTargetDiscretesRequest getEventStreamDecodeTargetDiscretesRequest, final ApiCallback<GetEventStreamDecodeTargetDiscretesDefaultResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = getEventStreamDecodeTargetDiscretesValidateBeforeCall(getEventStreamDecodeTargetDiscretesRequest, _callback);
        Type localVarReturnType = new TypeToken<GetEventStreamDecodeTargetDiscretesDefaultResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getEventStreamDiscreteValues
     * @param getEventStreamDiscreteValuesRequest Obtain discrete values from an event stream table             Supports use of a snapshot table which should reduce the chances of us blowing the Engine discrete limit.             The first parameters constitute the sankey filters and thereby the starting set for discretes             It will also allow us to filter the values by the specified discrete filters             If the sankey filters return no data then an execption is thrown stating that \&quot;No data is available for the specified filters\&quot; as this is probably not what the user wants             If the discretes filter suppresses out all data in the sankey then no exception is raised but zero totals are returned (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getEventStreamDiscreteValuesCall(GetEventStreamDiscreteValuesRequest getEventStreamDiscreteValuesRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = getEventStreamDiscreteValuesRequest;

        // create path and map variables
        String localVarPath = "/GetEventStreamDiscreteValues";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "TokenAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getEventStreamDiscreteValuesValidateBeforeCall(GetEventStreamDiscreteValuesRequest getEventStreamDiscreteValuesRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'getEventStreamDiscreteValuesRequest' is set
        if (getEventStreamDiscreteValuesRequest == null) {
            throw new ApiException("Missing the required parameter 'getEventStreamDiscreteValuesRequest' when calling getEventStreamDiscreteValues(Async)");
        }

        return getEventStreamDiscreteValuesCall(getEventStreamDiscreteValuesRequest, _callback);

    }

    /**
     * Obtain discrete values from an event stream table             Supports use of a snapshot table which should reduce the chances of us blowing the Engine discrete limit.             The first parameters constitute the sankey filters and thereby the starting set for discretes             It will also allow us to filter the values by the specified discrete filters             If the sankey filters return no data then an execption is thrown stating that \&quot;No data is available for the specified filters\&quot; as this is probably not what the user wants             If the discretes filter suppresses out all data in the sankey then no exception is raised but zero totals are returned
     * Obtain discrete values from an event stream table             Supports use of a snapshot table which should reduce the chances of us blowing the Engine discrete limit.             The first parameters constitute the sankey filters and thereby the starting set for discretes             It will also allow us to filter the values by the specified discrete filters             If the sankey filters return no data then an execption is thrown stating that \&quot;No data is available for the specified filters\&quot; as this is probably not what the user wants             If the discretes filter suppresses out all data in the sankey then no exception is raised but zero totals are returned
     * @param getEventStreamDiscreteValuesRequest Obtain discrete values from an event stream table             Supports use of a snapshot table which should reduce the chances of us blowing the Engine discrete limit.             The first parameters constitute the sankey filters and thereby the starting set for discretes             It will also allow us to filter the values by the specified discrete filters             If the sankey filters return no data then an execption is thrown stating that \&quot;No data is available for the specified filters\&quot; as this is probably not what the user wants             If the discretes filter suppresses out all data in the sankey then no exception is raised but zero totals are returned (required)
     * @return GetEventStreamDiscreteValuesDefaultResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public GetEventStreamDiscreteValuesDefaultResponse getEventStreamDiscreteValues(GetEventStreamDiscreteValuesRequest getEventStreamDiscreteValuesRequest) throws ApiException {
        ApiResponse<GetEventStreamDiscreteValuesDefaultResponse> localVarResp = getEventStreamDiscreteValuesWithHttpInfo(getEventStreamDiscreteValuesRequest);
        return localVarResp.getData();
    }

    /**
     * Obtain discrete values from an event stream table             Supports use of a snapshot table which should reduce the chances of us blowing the Engine discrete limit.             The first parameters constitute the sankey filters and thereby the starting set for discretes             It will also allow us to filter the values by the specified discrete filters             If the sankey filters return no data then an execption is thrown stating that \&quot;No data is available for the specified filters\&quot; as this is probably not what the user wants             If the discretes filter suppresses out all data in the sankey then no exception is raised but zero totals are returned
     * Obtain discrete values from an event stream table             Supports use of a snapshot table which should reduce the chances of us blowing the Engine discrete limit.             The first parameters constitute the sankey filters and thereby the starting set for discretes             It will also allow us to filter the values by the specified discrete filters             If the sankey filters return no data then an execption is thrown stating that \&quot;No data is available for the specified filters\&quot; as this is probably not what the user wants             If the discretes filter suppresses out all data in the sankey then no exception is raised but zero totals are returned
     * @param getEventStreamDiscreteValuesRequest Obtain discrete values from an event stream table             Supports use of a snapshot table which should reduce the chances of us blowing the Engine discrete limit.             The first parameters constitute the sankey filters and thereby the starting set for discretes             It will also allow us to filter the values by the specified discrete filters             If the sankey filters return no data then an execption is thrown stating that \&quot;No data is available for the specified filters\&quot; as this is probably not what the user wants             If the discretes filter suppresses out all data in the sankey then no exception is raised but zero totals are returned (required)
     * @return ApiResponse&lt;GetEventStreamDiscreteValuesDefaultResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<GetEventStreamDiscreteValuesDefaultResponse> getEventStreamDiscreteValuesWithHttpInfo(GetEventStreamDiscreteValuesRequest getEventStreamDiscreteValuesRequest) throws ApiException {
        okhttp3.Call localVarCall = getEventStreamDiscreteValuesValidateBeforeCall(getEventStreamDiscreteValuesRequest, null);
        Type localVarReturnType = new TypeToken<GetEventStreamDiscreteValuesDefaultResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Obtain discrete values from an event stream table             Supports use of a snapshot table which should reduce the chances of us blowing the Engine discrete limit.             The first parameters constitute the sankey filters and thereby the starting set for discretes             It will also allow us to filter the values by the specified discrete filters             If the sankey filters return no data then an execption is thrown stating that \&quot;No data is available for the specified filters\&quot; as this is probably not what the user wants             If the discretes filter suppresses out all data in the sankey then no exception is raised but zero totals are returned (asynchronously)
     * Obtain discrete values from an event stream table             Supports use of a snapshot table which should reduce the chances of us blowing the Engine discrete limit.             The first parameters constitute the sankey filters and thereby the starting set for discretes             It will also allow us to filter the values by the specified discrete filters             If the sankey filters return no data then an execption is thrown stating that \&quot;No data is available for the specified filters\&quot; as this is probably not what the user wants             If the discretes filter suppresses out all data in the sankey then no exception is raised but zero totals are returned
     * @param getEventStreamDiscreteValuesRequest Obtain discrete values from an event stream table             Supports use of a snapshot table which should reduce the chances of us blowing the Engine discrete limit.             The first parameters constitute the sankey filters and thereby the starting set for discretes             It will also allow us to filter the values by the specified discrete filters             If the sankey filters return no data then an execption is thrown stating that \&quot;No data is available for the specified filters\&quot; as this is probably not what the user wants             If the discretes filter suppresses out all data in the sankey then no exception is raised but zero totals are returned (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getEventStreamDiscreteValuesAsync(GetEventStreamDiscreteValuesRequest getEventStreamDiscreteValuesRequest, final ApiCallback<GetEventStreamDiscreteValuesDefaultResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = getEventStreamDiscreteValuesValidateBeforeCall(getEventStreamDiscreteValuesRequest, _callback);
        Type localVarReturnType = new TypeToken<GetEventStreamDiscreteValuesDefaultResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getEventStreamModels
     * @param getEventStreamModelsRequest Retrieve available models (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getEventStreamModelsCall(GetEventStreamModelsRequest getEventStreamModelsRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = getEventStreamModelsRequest;

        // create path and map variables
        String localVarPath = "/GetEventStreamModels";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "TokenAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getEventStreamModelsValidateBeforeCall(GetEventStreamModelsRequest getEventStreamModelsRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'getEventStreamModelsRequest' is set
        if (getEventStreamModelsRequest == null) {
            throw new ApiException("Missing the required parameter 'getEventStreamModelsRequest' when calling getEventStreamModels(Async)");
        }

        return getEventStreamModelsCall(getEventStreamModelsRequest, _callback);

    }

    /**
     * Retrieve available models
     * Retrieve available models
     * @param getEventStreamModelsRequest Retrieve available models (required)
     * @return GetEventStreamModelsDefaultResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public GetEventStreamModelsDefaultResponse getEventStreamModels(GetEventStreamModelsRequest getEventStreamModelsRequest) throws ApiException {
        ApiResponse<GetEventStreamModelsDefaultResponse> localVarResp = getEventStreamModelsWithHttpInfo(getEventStreamModelsRequest);
        return localVarResp.getData();
    }

    /**
     * Retrieve available models
     * Retrieve available models
     * @param getEventStreamModelsRequest Retrieve available models (required)
     * @return ApiResponse&lt;GetEventStreamModelsDefaultResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<GetEventStreamModelsDefaultResponse> getEventStreamModelsWithHttpInfo(GetEventStreamModelsRequest getEventStreamModelsRequest) throws ApiException {
        okhttp3.Call localVarCall = getEventStreamModelsValidateBeforeCall(getEventStreamModelsRequest, null);
        Type localVarReturnType = new TypeToken<GetEventStreamModelsDefaultResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Retrieve available models (asynchronously)
     * Retrieve available models
     * @param getEventStreamModelsRequest Retrieve available models (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getEventStreamModelsAsync(GetEventStreamModelsRequest getEventStreamModelsRequest, final ApiCallback<GetEventStreamModelsDefaultResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = getEventStreamModelsValidateBeforeCall(getEventStreamModelsRequest, _callback);
        Type localVarReturnType = new TypeToken<GetEventStreamModelsDefaultResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getEventStreams
     * @param getClientSetsRequest Returns back a list of event streams which exist in the system (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getEventStreamsCall(GetClientSetsRequest getClientSetsRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = getClientSetsRequest;

        // create path and map variables
        String localVarPath = "/GetEventStreams";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "TokenAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getEventStreamsValidateBeforeCall(GetClientSetsRequest getClientSetsRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'getClientSetsRequest' is set
        if (getClientSetsRequest == null) {
            throw new ApiException("Missing the required parameter 'getClientSetsRequest' when calling getEventStreams(Async)");
        }

        return getEventStreamsCall(getClientSetsRequest, _callback);

    }

    /**
     * Returns back a list of event streams which exist in the system
     * Returns back a list of event streams which exist in the system
     * @param getClientSetsRequest Returns back a list of event streams which exist in the system (required)
     * @return GetEventStreamsDefaultResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public GetEventStreamsDefaultResponse getEventStreams(GetClientSetsRequest getClientSetsRequest) throws ApiException {
        ApiResponse<GetEventStreamsDefaultResponse> localVarResp = getEventStreamsWithHttpInfo(getClientSetsRequest);
        return localVarResp.getData();
    }

    /**
     * Returns back a list of event streams which exist in the system
     * Returns back a list of event streams which exist in the system
     * @param getClientSetsRequest Returns back a list of event streams which exist in the system (required)
     * @return ApiResponse&lt;GetEventStreamsDefaultResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<GetEventStreamsDefaultResponse> getEventStreamsWithHttpInfo(GetClientSetsRequest getClientSetsRequest) throws ApiException {
        okhttp3.Call localVarCall = getEventStreamsValidateBeforeCall(getClientSetsRequest, null);
        Type localVarReturnType = new TypeToken<GetEventStreamsDefaultResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Returns back a list of event streams which exist in the system (asynchronously)
     * Returns back a list of event streams which exist in the system
     * @param getClientSetsRequest Returns back a list of event streams which exist in the system (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getEventStreamsAsync(GetClientSetsRequest getClientSetsRequest, final ApiCallback<GetEventStreamsDefaultResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = getEventStreamsValidateBeforeCall(getClientSetsRequest, _callback);
        Type localVarReturnType = new TypeToken<GetEventStreamsDefaultResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getFieldTransformationDiscreteValues
     * @param getFieldTransformationDiscreteValuesRequest Apply a list of transforms to the discrete values of a column and return the new set of values and their frequencies             If JSONTransforms is not supplied then the results will simply be the discrete values present in the source column after any sample has been applied (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getFieldTransformationDiscreteValuesCall(GetFieldTransformationDiscreteValuesRequest getFieldTransformationDiscreteValuesRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = getFieldTransformationDiscreteValuesRequest;

        // create path and map variables
        String localVarPath = "/GetFieldTransformationDiscreteValues";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "TokenAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getFieldTransformationDiscreteValuesValidateBeforeCall(GetFieldTransformationDiscreteValuesRequest getFieldTransformationDiscreteValuesRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'getFieldTransformationDiscreteValuesRequest' is set
        if (getFieldTransformationDiscreteValuesRequest == null) {
            throw new ApiException("Missing the required parameter 'getFieldTransformationDiscreteValuesRequest' when calling getFieldTransformationDiscreteValues(Async)");
        }

        return getFieldTransformationDiscreteValuesCall(getFieldTransformationDiscreteValuesRequest, _callback);

    }

    /**
     * Apply a list of transforms to the discrete values of a column and return the new set of values and their frequencies             If JSONTransforms is not supplied then the results will simply be the discrete values present in the source column after any sample has been applied
     * Apply a list of transforms to the discrete values of a column and return the new set of values and their frequencies             If JSONTransforms is not supplied then the results will simply be the discrete values present in the source column after any sample has been applied
     * @param getFieldTransformationDiscreteValuesRequest Apply a list of transforms to the discrete values of a column and return the new set of values and their frequencies             If JSONTransforms is not supplied then the results will simply be the discrete values present in the source column after any sample has been applied (required)
     * @return GetEventStreamDecodeTargetDiscretesDefaultResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public GetEventStreamDecodeTargetDiscretesDefaultResponse getFieldTransformationDiscreteValues(GetFieldTransformationDiscreteValuesRequest getFieldTransformationDiscreteValuesRequest) throws ApiException {
        ApiResponse<GetEventStreamDecodeTargetDiscretesDefaultResponse> localVarResp = getFieldTransformationDiscreteValuesWithHttpInfo(getFieldTransformationDiscreteValuesRequest);
        return localVarResp.getData();
    }

    /**
     * Apply a list of transforms to the discrete values of a column and return the new set of values and their frequencies             If JSONTransforms is not supplied then the results will simply be the discrete values present in the source column after any sample has been applied
     * Apply a list of transforms to the discrete values of a column and return the new set of values and their frequencies             If JSONTransforms is not supplied then the results will simply be the discrete values present in the source column after any sample has been applied
     * @param getFieldTransformationDiscreteValuesRequest Apply a list of transforms to the discrete values of a column and return the new set of values and their frequencies             If JSONTransforms is not supplied then the results will simply be the discrete values present in the source column after any sample has been applied (required)
     * @return ApiResponse&lt;GetEventStreamDecodeTargetDiscretesDefaultResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<GetEventStreamDecodeTargetDiscretesDefaultResponse> getFieldTransformationDiscreteValuesWithHttpInfo(GetFieldTransformationDiscreteValuesRequest getFieldTransformationDiscreteValuesRequest) throws ApiException {
        okhttp3.Call localVarCall = getFieldTransformationDiscreteValuesValidateBeforeCall(getFieldTransformationDiscreteValuesRequest, null);
        Type localVarReturnType = new TypeToken<GetEventStreamDecodeTargetDiscretesDefaultResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Apply a list of transforms to the discrete values of a column and return the new set of values and their frequencies             If JSONTransforms is not supplied then the results will simply be the discrete values present in the source column after any sample has been applied (asynchronously)
     * Apply a list of transforms to the discrete values of a column and return the new set of values and their frequencies             If JSONTransforms is not supplied then the results will simply be the discrete values present in the source column after any sample has been applied
     * @param getFieldTransformationDiscreteValuesRequest Apply a list of transforms to the discrete values of a column and return the new set of values and their frequencies             If JSONTransforms is not supplied then the results will simply be the discrete values present in the source column after any sample has been applied (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getFieldTransformationDiscreteValuesAsync(GetFieldTransformationDiscreteValuesRequest getFieldTransformationDiscreteValuesRequest, final ApiCallback<GetEventStreamDecodeTargetDiscretesDefaultResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = getFieldTransformationDiscreteValuesValidateBeforeCall(getFieldTransformationDiscreteValuesRequest, _callback);
        Type localVarReturnType = new TypeToken<GetEventStreamDecodeTargetDiscretesDefaultResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getFieldTransformationMappings
     * @param getFieldTransformationMappingsRequest Apply a list of transforms and return information about the transformed value and frequency for each item in the starting set of values             If JSONCompareTransforms is specified then the starting set of values is the result of first applying these to these to the specified column             If JSONCompareTransforms is not specified then the starting set of values is the actual discrete values present in the column (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getFieldTransformationMappingsCall(GetFieldTransformationMappingsRequest getFieldTransformationMappingsRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = getFieldTransformationMappingsRequest;

        // create path and map variables
        String localVarPath = "/GetFieldTransformationMappings";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "TokenAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getFieldTransformationMappingsValidateBeforeCall(GetFieldTransformationMappingsRequest getFieldTransformationMappingsRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'getFieldTransformationMappingsRequest' is set
        if (getFieldTransformationMappingsRequest == null) {
            throw new ApiException("Missing the required parameter 'getFieldTransformationMappingsRequest' when calling getFieldTransformationMappings(Async)");
        }

        return getFieldTransformationMappingsCall(getFieldTransformationMappingsRequest, _callback);

    }

    /**
     * Apply a list of transforms and return information about the transformed value and frequency for each item in the starting set of values             If JSONCompareTransforms is specified then the starting set of values is the result of first applying these to these to the specified column             If JSONCompareTransforms is not specified then the starting set of values is the actual discrete values present in the column
     * Apply a list of transforms and return information about the transformed value and frequency for each item in the starting set of values             If JSONCompareTransforms is specified then the starting set of values is the result of first applying these to these to the specified column             If JSONCompareTransforms is not specified then the starting set of values is the actual discrete values present in the column
     * @param getFieldTransformationMappingsRequest Apply a list of transforms and return information about the transformed value and frequency for each item in the starting set of values             If JSONCompareTransforms is specified then the starting set of values is the result of first applying these to these to the specified column             If JSONCompareTransforms is not specified then the starting set of values is the actual discrete values present in the column (required)
     * @return GetFieldTransformationMappingsDefaultResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public GetFieldTransformationMappingsDefaultResponse getFieldTransformationMappings(GetFieldTransformationMappingsRequest getFieldTransformationMappingsRequest) throws ApiException {
        ApiResponse<GetFieldTransformationMappingsDefaultResponse> localVarResp = getFieldTransformationMappingsWithHttpInfo(getFieldTransformationMappingsRequest);
        return localVarResp.getData();
    }

    /**
     * Apply a list of transforms and return information about the transformed value and frequency for each item in the starting set of values             If JSONCompareTransforms is specified then the starting set of values is the result of first applying these to these to the specified column             If JSONCompareTransforms is not specified then the starting set of values is the actual discrete values present in the column
     * Apply a list of transforms and return information about the transformed value and frequency for each item in the starting set of values             If JSONCompareTransforms is specified then the starting set of values is the result of first applying these to these to the specified column             If JSONCompareTransforms is not specified then the starting set of values is the actual discrete values present in the column
     * @param getFieldTransformationMappingsRequest Apply a list of transforms and return information about the transformed value and frequency for each item in the starting set of values             If JSONCompareTransforms is specified then the starting set of values is the result of first applying these to these to the specified column             If JSONCompareTransforms is not specified then the starting set of values is the actual discrete values present in the column (required)
     * @return ApiResponse&lt;GetFieldTransformationMappingsDefaultResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<GetFieldTransformationMappingsDefaultResponse> getFieldTransformationMappingsWithHttpInfo(GetFieldTransformationMappingsRequest getFieldTransformationMappingsRequest) throws ApiException {
        okhttp3.Call localVarCall = getFieldTransformationMappingsValidateBeforeCall(getFieldTransformationMappingsRequest, null);
        Type localVarReturnType = new TypeToken<GetFieldTransformationMappingsDefaultResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Apply a list of transforms and return information about the transformed value and frequency for each item in the starting set of values             If JSONCompareTransforms is specified then the starting set of values is the result of first applying these to these to the specified column             If JSONCompareTransforms is not specified then the starting set of values is the actual discrete values present in the column (asynchronously)
     * Apply a list of transforms and return information about the transformed value and frequency for each item in the starting set of values             If JSONCompareTransforms is specified then the starting set of values is the result of first applying these to these to the specified column             If JSONCompareTransforms is not specified then the starting set of values is the actual discrete values present in the column
     * @param getFieldTransformationMappingsRequest Apply a list of transforms and return information about the transformed value and frequency for each item in the starting set of values             If JSONCompareTransforms is specified then the starting set of values is the result of first applying these to these to the specified column             If JSONCompareTransforms is not specified then the starting set of values is the actual discrete values present in the column (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getFieldTransformationMappingsAsync(GetFieldTransformationMappingsRequest getFieldTransformationMappingsRequest, final ApiCallback<GetFieldTransformationMappingsDefaultResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = getFieldTransformationMappingsValidateBeforeCall(getFieldTransformationMappingsRequest, _callback);
        Type localVarReturnType = new TypeToken<GetFieldTransformationMappingsDefaultResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getIdealisedJourneys
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getIdealisedJourneysCall(final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/GetIdealisedJourneys";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "TokenAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getIdealisedJourneysValidateBeforeCall(final ApiCallback _callback) throws ApiException {
        return getIdealisedJourneysCall(_callback);

    }

    /**
     * Retrieve a list of Idealised Journeys
     * Retrieve a list of Idealised Journeys
     * @return GetIdealisedJourneysDefaultResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public GetIdealisedJourneysDefaultResponse getIdealisedJourneys() throws ApiException {
        ApiResponse<GetIdealisedJourneysDefaultResponse> localVarResp = getIdealisedJourneysWithHttpInfo();
        return localVarResp.getData();
    }

    /**
     * Retrieve a list of Idealised Journeys
     * Retrieve a list of Idealised Journeys
     * @return ApiResponse&lt;GetIdealisedJourneysDefaultResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<GetIdealisedJourneysDefaultResponse> getIdealisedJourneysWithHttpInfo() throws ApiException {
        okhttp3.Call localVarCall = getIdealisedJourneysValidateBeforeCall(null);
        Type localVarReturnType = new TypeToken<GetIdealisedJourneysDefaultResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Retrieve a list of Idealised Journeys (asynchronously)
     * Retrieve a list of Idealised Journeys
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getIdealisedJourneysAsync(final ApiCallback<GetIdealisedJourneysDefaultResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = getIdealisedJourneysValidateBeforeCall(_callback);
        Type localVarReturnType = new TypeToken<GetIdealisedJourneysDefaultResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getSankeyFavourites
     * @param getSankeyFavouritesRequest Retrieve a list of Sankey Favourites (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getSankeyFavouritesCall(GetSankeyFavouritesRequest getSankeyFavouritesRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = getSankeyFavouritesRequest;

        // create path and map variables
        String localVarPath = "/GetSankeyFavourites";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "TokenAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getSankeyFavouritesValidateBeforeCall(GetSankeyFavouritesRequest getSankeyFavouritesRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'getSankeyFavouritesRequest' is set
        if (getSankeyFavouritesRequest == null) {
            throw new ApiException("Missing the required parameter 'getSankeyFavouritesRequest' when calling getSankeyFavourites(Async)");
        }

        return getSankeyFavouritesCall(getSankeyFavouritesRequest, _callback);

    }

    /**
     * Retrieve a list of Sankey Favourites
     * Retrieve a list of Sankey Favourites
     * @param getSankeyFavouritesRequest Retrieve a list of Sankey Favourites (required)
     * @return GetSankeyFavouritesDefaultResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public GetSankeyFavouritesDefaultResponse getSankeyFavourites(GetSankeyFavouritesRequest getSankeyFavouritesRequest) throws ApiException {
        ApiResponse<GetSankeyFavouritesDefaultResponse> localVarResp = getSankeyFavouritesWithHttpInfo(getSankeyFavouritesRequest);
        return localVarResp.getData();
    }

    /**
     * Retrieve a list of Sankey Favourites
     * Retrieve a list of Sankey Favourites
     * @param getSankeyFavouritesRequest Retrieve a list of Sankey Favourites (required)
     * @return ApiResponse&lt;GetSankeyFavouritesDefaultResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<GetSankeyFavouritesDefaultResponse> getSankeyFavouritesWithHttpInfo(GetSankeyFavouritesRequest getSankeyFavouritesRequest) throws ApiException {
        okhttp3.Call localVarCall = getSankeyFavouritesValidateBeforeCall(getSankeyFavouritesRequest, null);
        Type localVarReturnType = new TypeToken<GetSankeyFavouritesDefaultResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Retrieve a list of Sankey Favourites (asynchronously)
     * Retrieve a list of Sankey Favourites
     * @param getSankeyFavouritesRequest Retrieve a list of Sankey Favourites (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getSankeyFavouritesAsync(GetSankeyFavouritesRequest getSankeyFavouritesRequest, final ApiCallback<GetSankeyFavouritesDefaultResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = getSankeyFavouritesValidateBeforeCall(getSankeyFavouritesRequest, _callback);
        Type localVarReturnType = new TypeToken<GetSankeyFavouritesDefaultResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getVisualisationFavourites
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getVisualisationFavouritesCall(final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/GetVisualisationFavourites";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "TokenAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getVisualisationFavouritesValidateBeforeCall(final ApiCallback _callback) throws ApiException {
        return getVisualisationFavouritesCall(_callback);

    }

    /**
     * Retrieve a list of Visualisation Favourites
     * Retrieve a list of Visualisation Favourites
     * @return GetVisualisationFavouritesDefaultResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public GetVisualisationFavouritesDefaultResponse getVisualisationFavourites() throws ApiException {
        ApiResponse<GetVisualisationFavouritesDefaultResponse> localVarResp = getVisualisationFavouritesWithHttpInfo();
        return localVarResp.getData();
    }

    /**
     * Retrieve a list of Visualisation Favourites
     * Retrieve a list of Visualisation Favourites
     * @return ApiResponse&lt;GetVisualisationFavouritesDefaultResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<GetVisualisationFavouritesDefaultResponse> getVisualisationFavouritesWithHttpInfo() throws ApiException {
        okhttp3.Call localVarCall = getVisualisationFavouritesValidateBeforeCall(null);
        Type localVarReturnType = new TypeToken<GetVisualisationFavouritesDefaultResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Retrieve a list of Visualisation Favourites (asynchronously)
     * Retrieve a list of Visualisation Favourites
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getVisualisationFavouritesAsync(final ApiCallback<GetVisualisationFavouritesDefaultResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = getVisualisationFavouritesValidateBeforeCall(_callback);
        Type localVarReturnType = new TypeToken<GetVisualisationFavouritesDefaultResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for queryEventStream
     * @param queryEventStreamRequest Queries the domain of selected event records that is represented by the date and event type filters, returning the list of events and graph of transition streams along with frequency counts.             Transitions will specify start and end points using indices into the list of events, along with some special values.             The &#39;Drop off&#39; points where a stream ends will be assigned an index of -1.             Any transition to an event that does not fall into the TopN specification will be assigned to an &#39;other events&#39; category with an index of -2.             Right aligned streams will be left-padded up to the MaxLength specification using a &#39;no event&#39; category with an index of -3.             If timeout events are required then the start of the sequence leading up to a timeout will be flagged with an index of -4 and the end with an index of -5. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call queryEventStreamCall(QueryEventStreamRequest queryEventStreamRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = queryEventStreamRequest;

        // create path and map variables
        String localVarPath = "/QueryEventStream";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "TokenAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call queryEventStreamValidateBeforeCall(QueryEventStreamRequest queryEventStreamRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'queryEventStreamRequest' is set
        if (queryEventStreamRequest == null) {
            throw new ApiException("Missing the required parameter 'queryEventStreamRequest' when calling queryEventStream(Async)");
        }

        return queryEventStreamCall(queryEventStreamRequest, _callback);

    }

    /**
     * Queries the domain of selected event records that is represented by the date and event type filters, returning the list of events and graph of transition streams along with frequency counts.             Transitions will specify start and end points using indices into the list of events, along with some special values.             The &#39;Drop off&#39; points where a stream ends will be assigned an index of -1.             Any transition to an event that does not fall into the TopN specification will be assigned to an &#39;other events&#39; category with an index of -2.             Right aligned streams will be left-padded up to the MaxLength specification using a &#39;no event&#39; category with an index of -3.             If timeout events are required then the start of the sequence leading up to a timeout will be flagged with an index of -4 and the end with an index of -5.
     * Queries the domain of selected event records that is represented by the date and event type filters, returning the list of events and graph of transition streams along with frequency counts.             Transitions will specify start and end points using indices into the list of events, along with some special values.             The &#39;Drop off&#39; points where a stream ends will be assigned an index of -1.             Any transition to an event that does not fall into the TopN specification will be assigned to an &#39;other events&#39; category with an index of -2.             Right aligned streams will be left-padded up to the MaxLength specification using a &#39;no event&#39; category with an index of -3.             If timeout events are required then the start of the sequence leading up to a timeout will be flagged with an index of -4 and the end with an index of -5.
     * @param queryEventStreamRequest Queries the domain of selected event records that is represented by the date and event type filters, returning the list of events and graph of transition streams along with frequency counts.             Transitions will specify start and end points using indices into the list of events, along with some special values.             The &#39;Drop off&#39; points where a stream ends will be assigned an index of -1.             Any transition to an event that does not fall into the TopN specification will be assigned to an &#39;other events&#39; category with an index of -2.             Right aligned streams will be left-padded up to the MaxLength specification using a &#39;no event&#39; category with an index of -3.             If timeout events are required then the start of the sequence leading up to a timeout will be flagged with an index of -4 and the end with an index of -5. (required)
     * @return QueryEventStreamDefaultResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public QueryEventStreamDefaultResponse queryEventStream(QueryEventStreamRequest queryEventStreamRequest) throws ApiException {
        ApiResponse<QueryEventStreamDefaultResponse> localVarResp = queryEventStreamWithHttpInfo(queryEventStreamRequest);
        return localVarResp.getData();
    }

    /**
     * Queries the domain of selected event records that is represented by the date and event type filters, returning the list of events and graph of transition streams along with frequency counts.             Transitions will specify start and end points using indices into the list of events, along with some special values.             The &#39;Drop off&#39; points where a stream ends will be assigned an index of -1.             Any transition to an event that does not fall into the TopN specification will be assigned to an &#39;other events&#39; category with an index of -2.             Right aligned streams will be left-padded up to the MaxLength specification using a &#39;no event&#39; category with an index of -3.             If timeout events are required then the start of the sequence leading up to a timeout will be flagged with an index of -4 and the end with an index of -5.
     * Queries the domain of selected event records that is represented by the date and event type filters, returning the list of events and graph of transition streams along with frequency counts.             Transitions will specify start and end points using indices into the list of events, along with some special values.             The &#39;Drop off&#39; points where a stream ends will be assigned an index of -1.             Any transition to an event that does not fall into the TopN specification will be assigned to an &#39;other events&#39; category with an index of -2.             Right aligned streams will be left-padded up to the MaxLength specification using a &#39;no event&#39; category with an index of -3.             If timeout events are required then the start of the sequence leading up to a timeout will be flagged with an index of -4 and the end with an index of -5.
     * @param queryEventStreamRequest Queries the domain of selected event records that is represented by the date and event type filters, returning the list of events and graph of transition streams along with frequency counts.             Transitions will specify start and end points using indices into the list of events, along with some special values.             The &#39;Drop off&#39; points where a stream ends will be assigned an index of -1.             Any transition to an event that does not fall into the TopN specification will be assigned to an &#39;other events&#39; category with an index of -2.             Right aligned streams will be left-padded up to the MaxLength specification using a &#39;no event&#39; category with an index of -3.             If timeout events are required then the start of the sequence leading up to a timeout will be flagged with an index of -4 and the end with an index of -5. (required)
     * @return ApiResponse&lt;QueryEventStreamDefaultResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<QueryEventStreamDefaultResponse> queryEventStreamWithHttpInfo(QueryEventStreamRequest queryEventStreamRequest) throws ApiException {
        okhttp3.Call localVarCall = queryEventStreamValidateBeforeCall(queryEventStreamRequest, null);
        Type localVarReturnType = new TypeToken<QueryEventStreamDefaultResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Queries the domain of selected event records that is represented by the date and event type filters, returning the list of events and graph of transition streams along with frequency counts.             Transitions will specify start and end points using indices into the list of events, along with some special values.             The &#39;Drop off&#39; points where a stream ends will be assigned an index of -1.             Any transition to an event that does not fall into the TopN specification will be assigned to an &#39;other events&#39; category with an index of -2.             Right aligned streams will be left-padded up to the MaxLength specification using a &#39;no event&#39; category with an index of -3.             If timeout events are required then the start of the sequence leading up to a timeout will be flagged with an index of -4 and the end with an index of -5. (asynchronously)
     * Queries the domain of selected event records that is represented by the date and event type filters, returning the list of events and graph of transition streams along with frequency counts.             Transitions will specify start and end points using indices into the list of events, along with some special values.             The &#39;Drop off&#39; points where a stream ends will be assigned an index of -1.             Any transition to an event that does not fall into the TopN specification will be assigned to an &#39;other events&#39; category with an index of -2.             Right aligned streams will be left-padded up to the MaxLength specification using a &#39;no event&#39; category with an index of -3.             If timeout events are required then the start of the sequence leading up to a timeout will be flagged with an index of -4 and the end with an index of -5.
     * @param queryEventStreamRequest Queries the domain of selected event records that is represented by the date and event type filters, returning the list of events and graph of transition streams along with frequency counts.             Transitions will specify start and end points using indices into the list of events, along with some special values.             The &#39;Drop off&#39; points where a stream ends will be assigned an index of -1.             Any transition to an event that does not fall into the TopN specification will be assigned to an &#39;other events&#39; category with an index of -2.             Right aligned streams will be left-padded up to the MaxLength specification using a &#39;no event&#39; category with an index of -3.             If timeout events are required then the start of the sequence leading up to a timeout will be flagged with an index of -4 and the end with an index of -5. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call queryEventStreamAsync(QueryEventStreamRequest queryEventStreamRequest, final ApiCallback<QueryEventStreamDefaultResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = queryEventStreamValidateBeforeCall(queryEventStreamRequest, _callback);
        Type localVarReturnType = new TypeToken<QueryEventStreamDefaultResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for queryEventStreamCount
     * @param queryEventStreamCountRequest Take the domain of selected event records that is represented by the date filters, and count streams matching the agreed patterns represented by the CountType parameter (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call queryEventStreamCountCall(QueryEventStreamCountRequest queryEventStreamCountRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = queryEventStreamCountRequest;

        // create path and map variables
        String localVarPath = "/QueryEventStreamCount";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "TokenAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call queryEventStreamCountValidateBeforeCall(QueryEventStreamCountRequest queryEventStreamCountRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'queryEventStreamCountRequest' is set
        if (queryEventStreamCountRequest == null) {
            throw new ApiException("Missing the required parameter 'queryEventStreamCountRequest' when calling queryEventStreamCount(Async)");
        }

        return queryEventStreamCountCall(queryEventStreamCountRequest, _callback);

    }

    /**
     * Take the domain of selected event records that is represented by the date filters, and count streams matching the agreed patterns represented by the CountType parameter
     * Take the domain of selected event records that is represented by the date filters, and count streams matching the agreed patterns represented by the CountType parameter
     * @param queryEventStreamCountRequest Take the domain of selected event records that is represented by the date filters, and count streams matching the agreed patterns represented by the CountType parameter (required)
     * @return QueryEventStreamCountDefaultResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public QueryEventStreamCountDefaultResponse queryEventStreamCount(QueryEventStreamCountRequest queryEventStreamCountRequest) throws ApiException {
        ApiResponse<QueryEventStreamCountDefaultResponse> localVarResp = queryEventStreamCountWithHttpInfo(queryEventStreamCountRequest);
        return localVarResp.getData();
    }

    /**
     * Take the domain of selected event records that is represented by the date filters, and count streams matching the agreed patterns represented by the CountType parameter
     * Take the domain of selected event records that is represented by the date filters, and count streams matching the agreed patterns represented by the CountType parameter
     * @param queryEventStreamCountRequest Take the domain of selected event records that is represented by the date filters, and count streams matching the agreed patterns represented by the CountType parameter (required)
     * @return ApiResponse&lt;QueryEventStreamCountDefaultResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<QueryEventStreamCountDefaultResponse> queryEventStreamCountWithHttpInfo(QueryEventStreamCountRequest queryEventStreamCountRequest) throws ApiException {
        okhttp3.Call localVarCall = queryEventStreamCountValidateBeforeCall(queryEventStreamCountRequest, null);
        Type localVarReturnType = new TypeToken<QueryEventStreamCountDefaultResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Take the domain of selected event records that is represented by the date filters, and count streams matching the agreed patterns represented by the CountType parameter (asynchronously)
     * Take the domain of selected event records that is represented by the date filters, and count streams matching the agreed patterns represented by the CountType parameter
     * @param queryEventStreamCountRequest Take the domain of selected event records that is represented by the date filters, and count streams matching the agreed patterns represented by the CountType parameter (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call queryEventStreamCountAsync(QueryEventStreamCountRequest queryEventStreamCountRequest, final ApiCallback<QueryEventStreamCountDefaultResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = queryEventStreamCountValidateBeforeCall(queryEventStreamCountRequest, _callback);
        Type localVarReturnType = new TypeToken<QueryEventStreamCountDefaultResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for queryEventStreamInteraction
     * @param exportEventStreamInteractionRequest Queries the domain of a particular node to return a sample of the CXID (VisitorId) values.             To get the results for \&quot;other\&quot; events pass all displayed events and set &#39;IncludeMatchedEvents&#39; to False. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call queryEventStreamInteractionCall(ExportEventStreamInteractionRequest exportEventStreamInteractionRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = exportEventStreamInteractionRequest;

        // create path and map variables
        String localVarPath = "/QueryEventStreamInteraction";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "TokenAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call queryEventStreamInteractionValidateBeforeCall(ExportEventStreamInteractionRequest exportEventStreamInteractionRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'exportEventStreamInteractionRequest' is set
        if (exportEventStreamInteractionRequest == null) {
            throw new ApiException("Missing the required parameter 'exportEventStreamInteractionRequest' when calling queryEventStreamInteraction(Async)");
        }

        return queryEventStreamInteractionCall(exportEventStreamInteractionRequest, _callback);

    }

    /**
     * Queries the domain of a particular node to return a sample of the CXID (VisitorId) values.             To get the results for \&quot;other\&quot; events pass all displayed events and set &#39;IncludeMatchedEvents&#39; to False.
     * Queries the domain of a particular node to return a sample of the CXID (VisitorId) values.             To get the results for \&quot;other\&quot; events pass all displayed events and set &#39;IncludeMatchedEvents&#39; to False.
     * @param exportEventStreamInteractionRequest Queries the domain of a particular node to return a sample of the CXID (VisitorId) values.             To get the results for \&quot;other\&quot; events pass all displayed events and set &#39;IncludeMatchedEvents&#39; to False. (required)
     * @return GetEventRecordsDefaultResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public GetEventRecordsDefaultResponse queryEventStreamInteraction(ExportEventStreamInteractionRequest exportEventStreamInteractionRequest) throws ApiException {
        ApiResponse<GetEventRecordsDefaultResponse> localVarResp = queryEventStreamInteractionWithHttpInfo(exportEventStreamInteractionRequest);
        return localVarResp.getData();
    }

    /**
     * Queries the domain of a particular node to return a sample of the CXID (VisitorId) values.             To get the results for \&quot;other\&quot; events pass all displayed events and set &#39;IncludeMatchedEvents&#39; to False.
     * Queries the domain of a particular node to return a sample of the CXID (VisitorId) values.             To get the results for \&quot;other\&quot; events pass all displayed events and set &#39;IncludeMatchedEvents&#39; to False.
     * @param exportEventStreamInteractionRequest Queries the domain of a particular node to return a sample of the CXID (VisitorId) values.             To get the results for \&quot;other\&quot; events pass all displayed events and set &#39;IncludeMatchedEvents&#39; to False. (required)
     * @return ApiResponse&lt;GetEventRecordsDefaultResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<GetEventRecordsDefaultResponse> queryEventStreamInteractionWithHttpInfo(ExportEventStreamInteractionRequest exportEventStreamInteractionRequest) throws ApiException {
        okhttp3.Call localVarCall = queryEventStreamInteractionValidateBeforeCall(exportEventStreamInteractionRequest, null);
        Type localVarReturnType = new TypeToken<GetEventRecordsDefaultResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Queries the domain of a particular node to return a sample of the CXID (VisitorId) values.             To get the results for \&quot;other\&quot; events pass all displayed events and set &#39;IncludeMatchedEvents&#39; to False. (asynchronously)
     * Queries the domain of a particular node to return a sample of the CXID (VisitorId) values.             To get the results for \&quot;other\&quot; events pass all displayed events and set &#39;IncludeMatchedEvents&#39; to False.
     * @param exportEventStreamInteractionRequest Queries the domain of a particular node to return a sample of the CXID (VisitorId) values.             To get the results for \&quot;other\&quot; events pass all displayed events and set &#39;IncludeMatchedEvents&#39; to False. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call queryEventStreamInteractionAsync(ExportEventStreamInteractionRequest exportEventStreamInteractionRequest, final ApiCallback<GetEventRecordsDefaultResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = queryEventStreamInteractionValidateBeforeCall(exportEventStreamInteractionRequest, _callback);
        Type localVarReturnType = new TypeToken<GetEventRecordsDefaultResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for queryEventStreamTransition
     * @param queryEventStreamTransitionRequest Queries the domain from a particular node to another node to return a sample of the CXID (VisitorId) values.             To get the results for \&quot;other\&quot; events pass all displayed events and set &#39;IncludeMatchedEventsFrom&#39; / IncludeMatchedEventsTo to False. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call queryEventStreamTransitionCall(QueryEventStreamTransitionRequest queryEventStreamTransitionRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = queryEventStreamTransitionRequest;

        // create path and map variables
        String localVarPath = "/QueryEventStreamTransition";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "TokenAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call queryEventStreamTransitionValidateBeforeCall(QueryEventStreamTransitionRequest queryEventStreamTransitionRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'queryEventStreamTransitionRequest' is set
        if (queryEventStreamTransitionRequest == null) {
            throw new ApiException("Missing the required parameter 'queryEventStreamTransitionRequest' when calling queryEventStreamTransition(Async)");
        }

        return queryEventStreamTransitionCall(queryEventStreamTransitionRequest, _callback);

    }

    /**
     * Queries the domain from a particular node to another node to return a sample of the CXID (VisitorId) values.             To get the results for \&quot;other\&quot; events pass all displayed events and set &#39;IncludeMatchedEventsFrom&#39; / IncludeMatchedEventsTo to False.
     * Queries the domain from a particular node to another node to return a sample of the CXID (VisitorId) values.             To get the results for \&quot;other\&quot; events pass all displayed events and set &#39;IncludeMatchedEventsFrom&#39; / IncludeMatchedEventsTo to False.
     * @param queryEventStreamTransitionRequest Queries the domain from a particular node to another node to return a sample of the CXID (VisitorId) values.             To get the results for \&quot;other\&quot; events pass all displayed events and set &#39;IncludeMatchedEventsFrom&#39; / IncludeMatchedEventsTo to False. (required)
     * @return GetEventRecordsDefaultResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public GetEventRecordsDefaultResponse queryEventStreamTransition(QueryEventStreamTransitionRequest queryEventStreamTransitionRequest) throws ApiException {
        ApiResponse<GetEventRecordsDefaultResponse> localVarResp = queryEventStreamTransitionWithHttpInfo(queryEventStreamTransitionRequest);
        return localVarResp.getData();
    }

    /**
     * Queries the domain from a particular node to another node to return a sample of the CXID (VisitorId) values.             To get the results for \&quot;other\&quot; events pass all displayed events and set &#39;IncludeMatchedEventsFrom&#39; / IncludeMatchedEventsTo to False.
     * Queries the domain from a particular node to another node to return a sample of the CXID (VisitorId) values.             To get the results for \&quot;other\&quot; events pass all displayed events and set &#39;IncludeMatchedEventsFrom&#39; / IncludeMatchedEventsTo to False.
     * @param queryEventStreamTransitionRequest Queries the domain from a particular node to another node to return a sample of the CXID (VisitorId) values.             To get the results for \&quot;other\&quot; events pass all displayed events and set &#39;IncludeMatchedEventsFrom&#39; / IncludeMatchedEventsTo to False. (required)
     * @return ApiResponse&lt;GetEventRecordsDefaultResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<GetEventRecordsDefaultResponse> queryEventStreamTransitionWithHttpInfo(QueryEventStreamTransitionRequest queryEventStreamTransitionRequest) throws ApiException {
        okhttp3.Call localVarCall = queryEventStreamTransitionValidateBeforeCall(queryEventStreamTransitionRequest, null);
        Type localVarReturnType = new TypeToken<GetEventRecordsDefaultResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Queries the domain from a particular node to another node to return a sample of the CXID (VisitorId) values.             To get the results for \&quot;other\&quot; events pass all displayed events and set &#39;IncludeMatchedEventsFrom&#39; / IncludeMatchedEventsTo to False. (asynchronously)
     * Queries the domain from a particular node to another node to return a sample of the CXID (VisitorId) values.             To get the results for \&quot;other\&quot; events pass all displayed events and set &#39;IncludeMatchedEventsFrom&#39; / IncludeMatchedEventsTo to False.
     * @param queryEventStreamTransitionRequest Queries the domain from a particular node to another node to return a sample of the CXID (VisitorId) values.             To get the results for \&quot;other\&quot; events pass all displayed events and set &#39;IncludeMatchedEventsFrom&#39; / IncludeMatchedEventsTo to False. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call queryEventStreamTransitionAsync(QueryEventStreamTransitionRequest queryEventStreamTransitionRequest, final ApiCallback<GetEventRecordsDefaultResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = queryEventStreamTransitionValidateBeforeCall(queryEventStreamTransitionRequest, _callback);
        Type localVarReturnType = new TypeToken<GetEventRecordsDefaultResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for runSequencePredictor
     * @param runSequencePredictorRequest Train and employ sequence prediction models for an event stream (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call runSequencePredictorCall(RunSequencePredictorRequest runSequencePredictorRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = runSequencePredictorRequest;

        // create path and map variables
        String localVarPath = "/RunSequencePredictor";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "TokenAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call runSequencePredictorValidateBeforeCall(RunSequencePredictorRequest runSequencePredictorRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'runSequencePredictorRequest' is set
        if (runSequencePredictorRequest == null) {
            throw new ApiException("Missing the required parameter 'runSequencePredictorRequest' when calling runSequencePredictor(Async)");
        }

        return runSequencePredictorCall(runSequencePredictorRequest, _callback);

    }

    /**
     * Train and employ sequence prediction models for an event stream
     * Train and employ sequence prediction models for an event stream
     * @param runSequencePredictorRequest Train and employ sequence prediction models for an event stream (required)
     * @return RunSequencePredictorDefaultResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public RunSequencePredictorDefaultResponse runSequencePredictor(RunSequencePredictorRequest runSequencePredictorRequest) throws ApiException {
        ApiResponse<RunSequencePredictorDefaultResponse> localVarResp = runSequencePredictorWithHttpInfo(runSequencePredictorRequest);
        return localVarResp.getData();
    }

    /**
     * Train and employ sequence prediction models for an event stream
     * Train and employ sequence prediction models for an event stream
     * @param runSequencePredictorRequest Train and employ sequence prediction models for an event stream (required)
     * @return ApiResponse&lt;RunSequencePredictorDefaultResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<RunSequencePredictorDefaultResponse> runSequencePredictorWithHttpInfo(RunSequencePredictorRequest runSequencePredictorRequest) throws ApiException {
        okhttp3.Call localVarCall = runSequencePredictorValidateBeforeCall(runSequencePredictorRequest, null);
        Type localVarReturnType = new TypeToken<RunSequencePredictorDefaultResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Train and employ sequence prediction models for an event stream (asynchronously)
     * Train and employ sequence prediction models for an event stream
     * @param runSequencePredictorRequest Train and employ sequence prediction models for an event stream (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call runSequencePredictorAsync(RunSequencePredictorRequest runSequencePredictorRequest, final ApiCallback<RunSequencePredictorDefaultResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = runSequencePredictorValidateBeforeCall(runSequencePredictorRequest, _callback);
        Type localVarReturnType = new TypeToken<RunSequencePredictorDefaultResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for updateChannel
     * @param updateChannelRequest Updates a channel, allowing you to change the name and colour (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call updateChannelCall(UpdateChannelRequest updateChannelRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = updateChannelRequest;

        // create path and map variables
        String localVarPath = "/UpdateChannel";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "TokenAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call updateChannelValidateBeforeCall(UpdateChannelRequest updateChannelRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'updateChannelRequest' is set
        if (updateChannelRequest == null) {
            throw new ApiException("Missing the required parameter 'updateChannelRequest' when calling updateChannel(Async)");
        }

        return updateChannelCall(updateChannelRequest, _callback);

    }

    /**
     * Updates a channel, allowing you to change the name and colour
     * Updates a channel, allowing you to change the name and colour
     * @param updateChannelRequest Updates a channel, allowing you to change the name and colour (required)
     * @return AUTHChangePasswordDefaultResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public AUTHChangePasswordDefaultResponse updateChannel(UpdateChannelRequest updateChannelRequest) throws ApiException {
        ApiResponse<AUTHChangePasswordDefaultResponse> localVarResp = updateChannelWithHttpInfo(updateChannelRequest);
        return localVarResp.getData();
    }

    /**
     * Updates a channel, allowing you to change the name and colour
     * Updates a channel, allowing you to change the name and colour
     * @param updateChannelRequest Updates a channel, allowing you to change the name and colour (required)
     * @return ApiResponse&lt;AUTHChangePasswordDefaultResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<AUTHChangePasswordDefaultResponse> updateChannelWithHttpInfo(UpdateChannelRequest updateChannelRequest) throws ApiException {
        okhttp3.Call localVarCall = updateChannelValidateBeforeCall(updateChannelRequest, null);
        Type localVarReturnType = new TypeToken<AUTHChangePasswordDefaultResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Updates a channel, allowing you to change the name and colour (asynchronously)
     * Updates a channel, allowing you to change the name and colour
     * @param updateChannelRequest Updates a channel, allowing you to change the name and colour (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call updateChannelAsync(UpdateChannelRequest updateChannelRequest, final ApiCallback<AUTHChangePasswordDefaultResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = updateChannelValidateBeforeCall(updateChannelRequest, _callback);
        Type localVarReturnType = new TypeToken<AUTHChangePasswordDefaultResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for updateEventStreamFieldTransformLists
     * @param updateEventStreamFieldTransformListsRequest Publishes the specified transforms to the corresponding event stream columns             Any existing list for a column that matches on Transform Type and Alias will be replaced (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call updateEventStreamFieldTransformListsCall(UpdateEventStreamFieldTransformListsRequest updateEventStreamFieldTransformListsRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = updateEventStreamFieldTransformListsRequest;

        // create path and map variables
        String localVarPath = "/UpdateEventStreamFieldTransformLists";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "TokenAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call updateEventStreamFieldTransformListsValidateBeforeCall(UpdateEventStreamFieldTransformListsRequest updateEventStreamFieldTransformListsRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'updateEventStreamFieldTransformListsRequest' is set
        if (updateEventStreamFieldTransformListsRequest == null) {
            throw new ApiException("Missing the required parameter 'updateEventStreamFieldTransformListsRequest' when calling updateEventStreamFieldTransformLists(Async)");
        }

        return updateEventStreamFieldTransformListsCall(updateEventStreamFieldTransformListsRequest, _callback);

    }

    /**
     * Publishes the specified transforms to the corresponding event stream columns             Any existing list for a column that matches on Transform Type and Alias will be replaced
     * Publishes the specified transforms to the corresponding event stream columns             Any existing list for a column that matches on Transform Type and Alias will be replaced
     * @param updateEventStreamFieldTransformListsRequest Publishes the specified transforms to the corresponding event stream columns             Any existing list for a column that matches on Transform Type and Alias will be replaced (required)
     * @return AUTHChangePasswordDefaultResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public AUTHChangePasswordDefaultResponse updateEventStreamFieldTransformLists(UpdateEventStreamFieldTransformListsRequest updateEventStreamFieldTransformListsRequest) throws ApiException {
        ApiResponse<AUTHChangePasswordDefaultResponse> localVarResp = updateEventStreamFieldTransformListsWithHttpInfo(updateEventStreamFieldTransformListsRequest);
        return localVarResp.getData();
    }

    /**
     * Publishes the specified transforms to the corresponding event stream columns             Any existing list for a column that matches on Transform Type and Alias will be replaced
     * Publishes the specified transforms to the corresponding event stream columns             Any existing list for a column that matches on Transform Type and Alias will be replaced
     * @param updateEventStreamFieldTransformListsRequest Publishes the specified transforms to the corresponding event stream columns             Any existing list for a column that matches on Transform Type and Alias will be replaced (required)
     * @return ApiResponse&lt;AUTHChangePasswordDefaultResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<AUTHChangePasswordDefaultResponse> updateEventStreamFieldTransformListsWithHttpInfo(UpdateEventStreamFieldTransformListsRequest updateEventStreamFieldTransformListsRequest) throws ApiException {
        okhttp3.Call localVarCall = updateEventStreamFieldTransformListsValidateBeforeCall(updateEventStreamFieldTransformListsRequest, null);
        Type localVarReturnType = new TypeToken<AUTHChangePasswordDefaultResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Publishes the specified transforms to the corresponding event stream columns             Any existing list for a column that matches on Transform Type and Alias will be replaced (asynchronously)
     * Publishes the specified transforms to the corresponding event stream columns             Any existing list for a column that matches on Transform Type and Alias will be replaced
     * @param updateEventStreamFieldTransformListsRequest Publishes the specified transforms to the corresponding event stream columns             Any existing list for a column that matches on Transform Type and Alias will be replaced (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call updateEventStreamFieldTransformListsAsync(UpdateEventStreamFieldTransformListsRequest updateEventStreamFieldTransformListsRequest, final ApiCallback<AUTHChangePasswordDefaultResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = updateEventStreamFieldTransformListsValidateBeforeCall(updateEventStreamFieldTransformListsRequest, _callback);
        Type localVarReturnType = new TypeToken<AUTHChangePasswordDefaultResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for updateIdealisedJourney
     * @param updateIdealisedJourneyRequest Update an Idealised Journey (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call updateIdealisedJourneyCall(UpdateIdealisedJourneyRequest updateIdealisedJourneyRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = updateIdealisedJourneyRequest;

        // create path and map variables
        String localVarPath = "/UpdateIdealisedJourney";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "TokenAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call updateIdealisedJourneyValidateBeforeCall(UpdateIdealisedJourneyRequest updateIdealisedJourneyRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'updateIdealisedJourneyRequest' is set
        if (updateIdealisedJourneyRequest == null) {
            throw new ApiException("Missing the required parameter 'updateIdealisedJourneyRequest' when calling updateIdealisedJourney(Async)");
        }

        return updateIdealisedJourneyCall(updateIdealisedJourneyRequest, _callback);

    }

    /**
     * Update an Idealised Journey
     * Update an Idealised Journey
     * @param updateIdealisedJourneyRequest Update an Idealised Journey (required)
     * @return AUTHChangePasswordDefaultResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public AUTHChangePasswordDefaultResponse updateIdealisedJourney(UpdateIdealisedJourneyRequest updateIdealisedJourneyRequest) throws ApiException {
        ApiResponse<AUTHChangePasswordDefaultResponse> localVarResp = updateIdealisedJourneyWithHttpInfo(updateIdealisedJourneyRequest);
        return localVarResp.getData();
    }

    /**
     * Update an Idealised Journey
     * Update an Idealised Journey
     * @param updateIdealisedJourneyRequest Update an Idealised Journey (required)
     * @return ApiResponse&lt;AUTHChangePasswordDefaultResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<AUTHChangePasswordDefaultResponse> updateIdealisedJourneyWithHttpInfo(UpdateIdealisedJourneyRequest updateIdealisedJourneyRequest) throws ApiException {
        okhttp3.Call localVarCall = updateIdealisedJourneyValidateBeforeCall(updateIdealisedJourneyRequest, null);
        Type localVarReturnType = new TypeToken<AUTHChangePasswordDefaultResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Update an Idealised Journey (asynchronously)
     * Update an Idealised Journey
     * @param updateIdealisedJourneyRequest Update an Idealised Journey (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call updateIdealisedJourneyAsync(UpdateIdealisedJourneyRequest updateIdealisedJourneyRequest, final ApiCallback<AUTHChangePasswordDefaultResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = updateIdealisedJourneyValidateBeforeCall(updateIdealisedJourneyRequest, _callback);
        Type localVarReturnType = new TypeToken<AUTHChangePasswordDefaultResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for updateSankeyFavourite
     * @param updateSankeyFavouriteRequest Update a SankeyFavourite (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call updateSankeyFavouriteCall(UpdateSankeyFavouriteRequest updateSankeyFavouriteRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = updateSankeyFavouriteRequest;

        // create path and map variables
        String localVarPath = "/UpdateSankeyFavourite";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "TokenAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call updateSankeyFavouriteValidateBeforeCall(UpdateSankeyFavouriteRequest updateSankeyFavouriteRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'updateSankeyFavouriteRequest' is set
        if (updateSankeyFavouriteRequest == null) {
            throw new ApiException("Missing the required parameter 'updateSankeyFavouriteRequest' when calling updateSankeyFavourite(Async)");
        }

        return updateSankeyFavouriteCall(updateSankeyFavouriteRequest, _callback);

    }

    /**
     * Update a SankeyFavourite
     * Update a SankeyFavourite
     * @param updateSankeyFavouriteRequest Update a SankeyFavourite (required)
     * @return AUTHChangePasswordDefaultResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public AUTHChangePasswordDefaultResponse updateSankeyFavourite(UpdateSankeyFavouriteRequest updateSankeyFavouriteRequest) throws ApiException {
        ApiResponse<AUTHChangePasswordDefaultResponse> localVarResp = updateSankeyFavouriteWithHttpInfo(updateSankeyFavouriteRequest);
        return localVarResp.getData();
    }

    /**
     * Update a SankeyFavourite
     * Update a SankeyFavourite
     * @param updateSankeyFavouriteRequest Update a SankeyFavourite (required)
     * @return ApiResponse&lt;AUTHChangePasswordDefaultResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<AUTHChangePasswordDefaultResponse> updateSankeyFavouriteWithHttpInfo(UpdateSankeyFavouriteRequest updateSankeyFavouriteRequest) throws ApiException {
        okhttp3.Call localVarCall = updateSankeyFavouriteValidateBeforeCall(updateSankeyFavouriteRequest, null);
        Type localVarReturnType = new TypeToken<AUTHChangePasswordDefaultResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Update a SankeyFavourite (asynchronously)
     * Update a SankeyFavourite
     * @param updateSankeyFavouriteRequest Update a SankeyFavourite (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call updateSankeyFavouriteAsync(UpdateSankeyFavouriteRequest updateSankeyFavouriteRequest, final ApiCallback<AUTHChangePasswordDefaultResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = updateSankeyFavouriteValidateBeforeCall(updateSankeyFavouriteRequest, _callback);
        Type localVarReturnType = new TypeToken<AUTHChangePasswordDefaultResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for updateVisualisationFavourite
     * @param updateVisualisationFavouriteRequest Update a Visualisation Favourite (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call updateVisualisationFavouriteCall(UpdateVisualisationFavouriteRequest updateVisualisationFavouriteRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = updateVisualisationFavouriteRequest;

        // create path and map variables
        String localVarPath = "/UpdateVisualisationFavourite";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "TokenAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call updateVisualisationFavouriteValidateBeforeCall(UpdateVisualisationFavouriteRequest updateVisualisationFavouriteRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'updateVisualisationFavouriteRequest' is set
        if (updateVisualisationFavouriteRequest == null) {
            throw new ApiException("Missing the required parameter 'updateVisualisationFavouriteRequest' when calling updateVisualisationFavourite(Async)");
        }

        return updateVisualisationFavouriteCall(updateVisualisationFavouriteRequest, _callback);

    }

    /**
     * Update a Visualisation Favourite
     * Update a Visualisation Favourite
     * @param updateVisualisationFavouriteRequest Update a Visualisation Favourite (required)
     * @return AUTHChangePasswordDefaultResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public AUTHChangePasswordDefaultResponse updateVisualisationFavourite(UpdateVisualisationFavouriteRequest updateVisualisationFavouriteRequest) throws ApiException {
        ApiResponse<AUTHChangePasswordDefaultResponse> localVarResp = updateVisualisationFavouriteWithHttpInfo(updateVisualisationFavouriteRequest);
        return localVarResp.getData();
    }

    /**
     * Update a Visualisation Favourite
     * Update a Visualisation Favourite
     * @param updateVisualisationFavouriteRequest Update a Visualisation Favourite (required)
     * @return ApiResponse&lt;AUTHChangePasswordDefaultResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<AUTHChangePasswordDefaultResponse> updateVisualisationFavouriteWithHttpInfo(UpdateVisualisationFavouriteRequest updateVisualisationFavouriteRequest) throws ApiException {
        okhttp3.Call localVarCall = updateVisualisationFavouriteValidateBeforeCall(updateVisualisationFavouriteRequest, null);
        Type localVarReturnType = new TypeToken<AUTHChangePasswordDefaultResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Update a Visualisation Favourite (asynchronously)
     * Update a Visualisation Favourite
     * @param updateVisualisationFavouriteRequest Update a Visualisation Favourite (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call updateVisualisationFavouriteAsync(UpdateVisualisationFavouriteRequest updateVisualisationFavouriteRequest, final ApiCallback<AUTHChangePasswordDefaultResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = updateVisualisationFavouriteValidateBeforeCall(updateVisualisationFavouriteRequest, _callback);
        Type localVarReturnType = new TypeToken<AUTHChangePasswordDefaultResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for upsertEventStreamCustomerColumns
     * @param upsertEventStreamCustomerColumnsRequest Add or update customer attribute columns for an @see(EventStream).             Only updates to column width (that are atomic and have no truncation risk) are currenty supported.              Width only needs to be specified for text or unicode columns.              The number of allowed columns is capped.              Customer attribute columns must maintain discrete cardinality to be used in the Sankey.              Names must meet Engine naming requirements. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call upsertEventStreamCustomerColumnsCall(UpsertEventStreamCustomerColumnsRequest upsertEventStreamCustomerColumnsRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = upsertEventStreamCustomerColumnsRequest;

        // create path and map variables
        String localVarPath = "/UpsertEventStreamCustomerColumns";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "TokenAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call upsertEventStreamCustomerColumnsValidateBeforeCall(UpsertEventStreamCustomerColumnsRequest upsertEventStreamCustomerColumnsRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'upsertEventStreamCustomerColumnsRequest' is set
        if (upsertEventStreamCustomerColumnsRequest == null) {
            throw new ApiException("Missing the required parameter 'upsertEventStreamCustomerColumnsRequest' when calling upsertEventStreamCustomerColumns(Async)");
        }

        return upsertEventStreamCustomerColumnsCall(upsertEventStreamCustomerColumnsRequest, _callback);

    }

    /**
     * Add or update customer attribute columns for an @see(EventStream).             Only updates to column width (that are atomic and have no truncation risk) are currenty supported.              Width only needs to be specified for text or unicode columns.              The number of allowed columns is capped.              Customer attribute columns must maintain discrete cardinality to be used in the Sankey.              Names must meet Engine naming requirements.
     * Add or update customer attribute columns for an @see(EventStream).             Only updates to column width (that are atomic and have no truncation risk) are currenty supported.              Width only needs to be specified for text or unicode columns.              The number of allowed columns is capped.              Customer attribute columns must maintain discrete cardinality to be used in the Sankey.              Names must meet Engine naming requirements.
     * @param upsertEventStreamCustomerColumnsRequest Add or update customer attribute columns for an @see(EventStream).             Only updates to column width (that are atomic and have no truncation risk) are currenty supported.              Width only needs to be specified for text or unicode columns.              The number of allowed columns is capped.              Customer attribute columns must maintain discrete cardinality to be used in the Sankey.              Names must meet Engine naming requirements. (required)
     * @return AUTHChangePasswordDefaultResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public AUTHChangePasswordDefaultResponse upsertEventStreamCustomerColumns(UpsertEventStreamCustomerColumnsRequest upsertEventStreamCustomerColumnsRequest) throws ApiException {
        ApiResponse<AUTHChangePasswordDefaultResponse> localVarResp = upsertEventStreamCustomerColumnsWithHttpInfo(upsertEventStreamCustomerColumnsRequest);
        return localVarResp.getData();
    }

    /**
     * Add or update customer attribute columns for an @see(EventStream).             Only updates to column width (that are atomic and have no truncation risk) are currenty supported.              Width only needs to be specified for text or unicode columns.              The number of allowed columns is capped.              Customer attribute columns must maintain discrete cardinality to be used in the Sankey.              Names must meet Engine naming requirements.
     * Add or update customer attribute columns for an @see(EventStream).             Only updates to column width (that are atomic and have no truncation risk) are currenty supported.              Width only needs to be specified for text or unicode columns.              The number of allowed columns is capped.              Customer attribute columns must maintain discrete cardinality to be used in the Sankey.              Names must meet Engine naming requirements.
     * @param upsertEventStreamCustomerColumnsRequest Add or update customer attribute columns for an @see(EventStream).             Only updates to column width (that are atomic and have no truncation risk) are currenty supported.              Width only needs to be specified for text or unicode columns.              The number of allowed columns is capped.              Customer attribute columns must maintain discrete cardinality to be used in the Sankey.              Names must meet Engine naming requirements. (required)
     * @return ApiResponse&lt;AUTHChangePasswordDefaultResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<AUTHChangePasswordDefaultResponse> upsertEventStreamCustomerColumnsWithHttpInfo(UpsertEventStreamCustomerColumnsRequest upsertEventStreamCustomerColumnsRequest) throws ApiException {
        okhttp3.Call localVarCall = upsertEventStreamCustomerColumnsValidateBeforeCall(upsertEventStreamCustomerColumnsRequest, null);
        Type localVarReturnType = new TypeToken<AUTHChangePasswordDefaultResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Add or update customer attribute columns for an @see(EventStream).             Only updates to column width (that are atomic and have no truncation risk) are currenty supported.              Width only needs to be specified for text or unicode columns.              The number of allowed columns is capped.              Customer attribute columns must maintain discrete cardinality to be used in the Sankey.              Names must meet Engine naming requirements. (asynchronously)
     * Add or update customer attribute columns for an @see(EventStream).             Only updates to column width (that are atomic and have no truncation risk) are currenty supported.              Width only needs to be specified for text or unicode columns.              The number of allowed columns is capped.              Customer attribute columns must maintain discrete cardinality to be used in the Sankey.              Names must meet Engine naming requirements.
     * @param upsertEventStreamCustomerColumnsRequest Add or update customer attribute columns for an @see(EventStream).             Only updates to column width (that are atomic and have no truncation risk) are currenty supported.              Width only needs to be specified for text or unicode columns.              The number of allowed columns is capped.              Customer attribute columns must maintain discrete cardinality to be used in the Sankey.              Names must meet Engine naming requirements. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call upsertEventStreamCustomerColumnsAsync(UpsertEventStreamCustomerColumnsRequest upsertEventStreamCustomerColumnsRequest, final ApiCallback<AUTHChangePasswordDefaultResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = upsertEventStreamCustomerColumnsValidateBeforeCall(upsertEventStreamCustomerColumnsRequest, _callback);
        Type localVarReturnType = new TypeToken<AUTHChangePasswordDefaultResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for upsertEventStreamCustomerColumnsToGroup
     * @param upsertEventStreamCustomerColumnsToGroupRequest Add or update customer attribute columns to the @see(EventStream)s in a group.             Only updates to column width (that are atomic and have no truncation risk) are currenty supported.              Width only needs to be specified for text or unicode columns.              The number of allowed columns is capped.              Customer attribute columns must maintain discrete cardinality to be used in the Sankey.              Names must meet Engine naming requirements.             There is some latency (up to 5 mins) between a column being created and the queue service starting to read the data unless the queue service is restarted (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call upsertEventStreamCustomerColumnsToGroupCall(UpsertEventStreamCustomerColumnsToGroupRequest upsertEventStreamCustomerColumnsToGroupRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = upsertEventStreamCustomerColumnsToGroupRequest;

        // create path and map variables
        String localVarPath = "/UpsertEventStreamCustomerColumnsToGroup";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "TokenAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call upsertEventStreamCustomerColumnsToGroupValidateBeforeCall(UpsertEventStreamCustomerColumnsToGroupRequest upsertEventStreamCustomerColumnsToGroupRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'upsertEventStreamCustomerColumnsToGroupRequest' is set
        if (upsertEventStreamCustomerColumnsToGroupRequest == null) {
            throw new ApiException("Missing the required parameter 'upsertEventStreamCustomerColumnsToGroupRequest' when calling upsertEventStreamCustomerColumnsToGroup(Async)");
        }

        return upsertEventStreamCustomerColumnsToGroupCall(upsertEventStreamCustomerColumnsToGroupRequest, _callback);

    }

    /**
     * Add or update customer attribute columns to the @see(EventStream)s in a group.             Only updates to column width (that are atomic and have no truncation risk) are currenty supported.              Width only needs to be specified for text or unicode columns.              The number of allowed columns is capped.              Customer attribute columns must maintain discrete cardinality to be used in the Sankey.              Names must meet Engine naming requirements.             There is some latency (up to 5 mins) between a column being created and the queue service starting to read the data unless the queue service is restarted
     * Add or update customer attribute columns to the @see(EventStream)s in a group.             Only updates to column width (that are atomic and have no truncation risk) are currenty supported.              Width only needs to be specified for text or unicode columns.              The number of allowed columns is capped.              Customer attribute columns must maintain discrete cardinality to be used in the Sankey.              Names must meet Engine naming requirements.             There is some latency (up to 5 mins) between a column being created and the queue service starting to read the data unless the queue service is restarted
     * @param upsertEventStreamCustomerColumnsToGroupRequest Add or update customer attribute columns to the @see(EventStream)s in a group.             Only updates to column width (that are atomic and have no truncation risk) are currenty supported.              Width only needs to be specified for text or unicode columns.              The number of allowed columns is capped.              Customer attribute columns must maintain discrete cardinality to be used in the Sankey.              Names must meet Engine naming requirements.             There is some latency (up to 5 mins) between a column being created and the queue service starting to read the data unless the queue service is restarted (required)
     * @return AUTHChangePasswordDefaultResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public AUTHChangePasswordDefaultResponse upsertEventStreamCustomerColumnsToGroup(UpsertEventStreamCustomerColumnsToGroupRequest upsertEventStreamCustomerColumnsToGroupRequest) throws ApiException {
        ApiResponse<AUTHChangePasswordDefaultResponse> localVarResp = upsertEventStreamCustomerColumnsToGroupWithHttpInfo(upsertEventStreamCustomerColumnsToGroupRequest);
        return localVarResp.getData();
    }

    /**
     * Add or update customer attribute columns to the @see(EventStream)s in a group.             Only updates to column width (that are atomic and have no truncation risk) are currenty supported.              Width only needs to be specified for text or unicode columns.              The number of allowed columns is capped.              Customer attribute columns must maintain discrete cardinality to be used in the Sankey.              Names must meet Engine naming requirements.             There is some latency (up to 5 mins) between a column being created and the queue service starting to read the data unless the queue service is restarted
     * Add or update customer attribute columns to the @see(EventStream)s in a group.             Only updates to column width (that are atomic and have no truncation risk) are currenty supported.              Width only needs to be specified for text or unicode columns.              The number of allowed columns is capped.              Customer attribute columns must maintain discrete cardinality to be used in the Sankey.              Names must meet Engine naming requirements.             There is some latency (up to 5 mins) between a column being created and the queue service starting to read the data unless the queue service is restarted
     * @param upsertEventStreamCustomerColumnsToGroupRequest Add or update customer attribute columns to the @see(EventStream)s in a group.             Only updates to column width (that are atomic and have no truncation risk) are currenty supported.              Width only needs to be specified for text or unicode columns.              The number of allowed columns is capped.              Customer attribute columns must maintain discrete cardinality to be used in the Sankey.              Names must meet Engine naming requirements.             There is some latency (up to 5 mins) between a column being created and the queue service starting to read the data unless the queue service is restarted (required)
     * @return ApiResponse&lt;AUTHChangePasswordDefaultResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<AUTHChangePasswordDefaultResponse> upsertEventStreamCustomerColumnsToGroupWithHttpInfo(UpsertEventStreamCustomerColumnsToGroupRequest upsertEventStreamCustomerColumnsToGroupRequest) throws ApiException {
        okhttp3.Call localVarCall = upsertEventStreamCustomerColumnsToGroupValidateBeforeCall(upsertEventStreamCustomerColumnsToGroupRequest, null);
        Type localVarReturnType = new TypeToken<AUTHChangePasswordDefaultResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Add or update customer attribute columns to the @see(EventStream)s in a group.             Only updates to column width (that are atomic and have no truncation risk) are currenty supported.              Width only needs to be specified for text or unicode columns.              The number of allowed columns is capped.              Customer attribute columns must maintain discrete cardinality to be used in the Sankey.              Names must meet Engine naming requirements.             There is some latency (up to 5 mins) between a column being created and the queue service starting to read the data unless the queue service is restarted (asynchronously)
     * Add or update customer attribute columns to the @see(EventStream)s in a group.             Only updates to column width (that are atomic and have no truncation risk) are currenty supported.              Width only needs to be specified for text or unicode columns.              The number of allowed columns is capped.              Customer attribute columns must maintain discrete cardinality to be used in the Sankey.              Names must meet Engine naming requirements.             There is some latency (up to 5 mins) between a column being created and the queue service starting to read the data unless the queue service is restarted
     * @param upsertEventStreamCustomerColumnsToGroupRequest Add or update customer attribute columns to the @see(EventStream)s in a group.             Only updates to column width (that are atomic and have no truncation risk) are currenty supported.              Width only needs to be specified for text or unicode columns.              The number of allowed columns is capped.              Customer attribute columns must maintain discrete cardinality to be used in the Sankey.              Names must meet Engine naming requirements.             There is some latency (up to 5 mins) between a column being created and the queue service starting to read the data unless the queue service is restarted (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call upsertEventStreamCustomerColumnsToGroupAsync(UpsertEventStreamCustomerColumnsToGroupRequest upsertEventStreamCustomerColumnsToGroupRequest, final ApiCallback<AUTHChangePasswordDefaultResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = upsertEventStreamCustomerColumnsToGroupValidateBeforeCall(upsertEventStreamCustomerColumnsToGroupRequest, _callback);
        Type localVarReturnType = new TypeToken<AUTHChangePasswordDefaultResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
}
