/*
 * Journey Analytics API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 6.35.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.alterian.ja.api;

import com.alterian.ja.ApiCallback;
import com.alterian.ja.ApiClient;
import com.alterian.ja.ApiException;
import com.alterian.ja.ApiResponse;
import com.alterian.ja.Configuration;
import com.alterian.ja.Pair;
import com.alterian.ja.ProgressRequestBody;
import com.alterian.ja.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import com.alterian.ja.model.AUTHChangePasswordDefaultResponse;
import com.alterian.ja.model.CreateClientDefaultResponse;
import com.alterian.ja.model.CreatePatternRequest;
import com.alterian.ja.model.CreatePatternTasksDefaultResponse;
import com.alterian.ja.model.CreatePatternTasksRequest;
import com.alterian.ja.model.DeletePatternRequest;
import com.alterian.ja.model.GetEventRecordsDefaultResponse;
import com.alterian.ja.model.GetPatternDefaultResponse;
import com.alterian.ja.model.GetPatternRecordsRequest;
import com.alterian.ja.model.GetPatternRequest;
import com.alterian.ja.model.GetPatternTasksRequest;
import com.alterian.ja.model.GetPatternsDefaultResponse;
import com.alterian.ja.model.GetPatternsRequest;
import com.alterian.ja.model.GetRepeatingPatternItemScoresDefaultResponse;
import com.alterian.ja.model.GetRepeatingPatternItemScoresRequest;
import com.alterian.ja.model.GetRepeatingPatternItemsRequest;
import com.alterian.ja.model.RequestCancelPatternTasksRequest;
import com.alterian.ja.model.UpdatePatternRequest;
import com.alterian.ja.model.UpdateRepeatingPatternItemScoresRequest;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class PatternsApi {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public PatternsApi() {
        this(Configuration.getDefaultApiClient());
    }

    public PatternsApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    /**
     * Build call for createPattern
     * @param createPatternRequest Creates a Pattern definition to capture settings and record where any output is located. The actual detected patterns will not be populated until tasks are run against it (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call createPatternCall(CreatePatternRequest createPatternRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = createPatternRequest;

        // create path and map variables
        String localVarPath = "/CreatePattern";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "TokenAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call createPatternValidateBeforeCall(CreatePatternRequest createPatternRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'createPatternRequest' is set
        if (createPatternRequest == null) {
            throw new ApiException("Missing the required parameter 'createPatternRequest' when calling createPattern(Async)");
        }

        return createPatternCall(createPatternRequest, _callback);

    }

    /**
     * Creates a Pattern definition to capture settings and record where any output is located. The actual detected patterns will not be populated until tasks are run against it
     * Creates a Pattern definition to capture settings and record where any output is located. The actual detected patterns will not be populated until tasks are run against it
     * @param createPatternRequest Creates a Pattern definition to capture settings and record where any output is located. The actual detected patterns will not be populated until tasks are run against it (required)
     * @return CreateClientDefaultResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public CreateClientDefaultResponse createPattern(CreatePatternRequest createPatternRequest) throws ApiException {
        ApiResponse<CreateClientDefaultResponse> localVarResp = createPatternWithHttpInfo(createPatternRequest);
        return localVarResp.getData();
    }

    /**
     * Creates a Pattern definition to capture settings and record where any output is located. The actual detected patterns will not be populated until tasks are run against it
     * Creates a Pattern definition to capture settings and record where any output is located. The actual detected patterns will not be populated until tasks are run against it
     * @param createPatternRequest Creates a Pattern definition to capture settings and record where any output is located. The actual detected patterns will not be populated until tasks are run against it (required)
     * @return ApiResponse&lt;CreateClientDefaultResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<CreateClientDefaultResponse> createPatternWithHttpInfo(CreatePatternRequest createPatternRequest) throws ApiException {
        okhttp3.Call localVarCall = createPatternValidateBeforeCall(createPatternRequest, null);
        Type localVarReturnType = new TypeToken<CreateClientDefaultResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Creates a Pattern definition to capture settings and record where any output is located. The actual detected patterns will not be populated until tasks are run against it (asynchronously)
     * Creates a Pattern definition to capture settings and record where any output is located. The actual detected patterns will not be populated until tasks are run against it
     * @param createPatternRequest Creates a Pattern definition to capture settings and record where any output is located. The actual detected patterns will not be populated until tasks are run against it (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call createPatternAsync(CreatePatternRequest createPatternRequest, final ApiCallback<CreateClientDefaultResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = createPatternValidateBeforeCall(createPatternRequest, _callback);
        Type localVarReturnType = new TypeToken<CreateClientDefaultResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for createPatternTasks
     * @param createPatternTasksRequest Creates a task to perform an action against a pattern definition (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call createPatternTasksCall(CreatePatternTasksRequest createPatternTasksRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = createPatternTasksRequest;

        // create path and map variables
        String localVarPath = "/CreatePatternTasks";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "TokenAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call createPatternTasksValidateBeforeCall(CreatePatternTasksRequest createPatternTasksRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'createPatternTasksRequest' is set
        if (createPatternTasksRequest == null) {
            throw new ApiException("Missing the required parameter 'createPatternTasksRequest' when calling createPatternTasks(Async)");
        }

        return createPatternTasksCall(createPatternTasksRequest, _callback);

    }

    /**
     * Creates a task to perform an action against a pattern definition
     * Creates a task to perform an action against a pattern definition
     * @param createPatternTasksRequest Creates a task to perform an action against a pattern definition (required)
     * @return CreatePatternTasksDefaultResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public CreatePatternTasksDefaultResponse createPatternTasks(CreatePatternTasksRequest createPatternTasksRequest) throws ApiException {
        ApiResponse<CreatePatternTasksDefaultResponse> localVarResp = createPatternTasksWithHttpInfo(createPatternTasksRequest);
        return localVarResp.getData();
    }

    /**
     * Creates a task to perform an action against a pattern definition
     * Creates a task to perform an action against a pattern definition
     * @param createPatternTasksRequest Creates a task to perform an action against a pattern definition (required)
     * @return ApiResponse&lt;CreatePatternTasksDefaultResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<CreatePatternTasksDefaultResponse> createPatternTasksWithHttpInfo(CreatePatternTasksRequest createPatternTasksRequest) throws ApiException {
        okhttp3.Call localVarCall = createPatternTasksValidateBeforeCall(createPatternTasksRequest, null);
        Type localVarReturnType = new TypeToken<CreatePatternTasksDefaultResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Creates a task to perform an action against a pattern definition (asynchronously)
     * Creates a task to perform an action against a pattern definition
     * @param createPatternTasksRequest Creates a task to perform an action against a pattern definition (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call createPatternTasksAsync(CreatePatternTasksRequest createPatternTasksRequest, final ApiCallback<CreatePatternTasksDefaultResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = createPatternTasksValidateBeforeCall(createPatternTasksRequest, _callback);
        Type localVarReturnType = new TypeToken<CreatePatternTasksDefaultResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for deletePattern
     * @param deletePatternRequest Delete one or more pattern definitions (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call deletePatternCall(DeletePatternRequest deletePatternRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = deletePatternRequest;

        // create path and map variables
        String localVarPath = "/DeletePattern";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "TokenAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call deletePatternValidateBeforeCall(DeletePatternRequest deletePatternRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'deletePatternRequest' is set
        if (deletePatternRequest == null) {
            throw new ApiException("Missing the required parameter 'deletePatternRequest' when calling deletePattern(Async)");
        }

        return deletePatternCall(deletePatternRequest, _callback);

    }

    /**
     * Delete one or more pattern definitions
     * Delete one or more pattern definitions
     * @param deletePatternRequest Delete one or more pattern definitions (required)
     * @return AUTHChangePasswordDefaultResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public AUTHChangePasswordDefaultResponse deletePattern(DeletePatternRequest deletePatternRequest) throws ApiException {
        ApiResponse<AUTHChangePasswordDefaultResponse> localVarResp = deletePatternWithHttpInfo(deletePatternRequest);
        return localVarResp.getData();
    }

    /**
     * Delete one or more pattern definitions
     * Delete one or more pattern definitions
     * @param deletePatternRequest Delete one or more pattern definitions (required)
     * @return ApiResponse&lt;AUTHChangePasswordDefaultResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<AUTHChangePasswordDefaultResponse> deletePatternWithHttpInfo(DeletePatternRequest deletePatternRequest) throws ApiException {
        okhttp3.Call localVarCall = deletePatternValidateBeforeCall(deletePatternRequest, null);
        Type localVarReturnType = new TypeToken<AUTHChangePasswordDefaultResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Delete one or more pattern definitions (asynchronously)
     * Delete one or more pattern definitions
     * @param deletePatternRequest Delete one or more pattern definitions (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call deletePatternAsync(DeletePatternRequest deletePatternRequest, final ApiCallback<AUTHChangePasswordDefaultResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = deletePatternValidateBeforeCall(deletePatternRequest, _callback);
        Type localVarReturnType = new TypeToken<AUTHChangePasswordDefaultResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getPattern
     * @param getPatternRequest Get a pattern definition (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getPatternCall(GetPatternRequest getPatternRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = getPatternRequest;

        // create path and map variables
        String localVarPath = "/GetPattern";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "TokenAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getPatternValidateBeforeCall(GetPatternRequest getPatternRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'getPatternRequest' is set
        if (getPatternRequest == null) {
            throw new ApiException("Missing the required parameter 'getPatternRequest' when calling getPattern(Async)");
        }

        return getPatternCall(getPatternRequest, _callback);

    }

    /**
     * Get a pattern definition
     * Get a pattern definition
     * @param getPatternRequest Get a pattern definition (required)
     * @return GetPatternDefaultResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public GetPatternDefaultResponse getPattern(GetPatternRequest getPatternRequest) throws ApiException {
        ApiResponse<GetPatternDefaultResponse> localVarResp = getPatternWithHttpInfo(getPatternRequest);
        return localVarResp.getData();
    }

    /**
     * Get a pattern definition
     * Get a pattern definition
     * @param getPatternRequest Get a pattern definition (required)
     * @return ApiResponse&lt;GetPatternDefaultResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<GetPatternDefaultResponse> getPatternWithHttpInfo(GetPatternRequest getPatternRequest) throws ApiException {
        okhttp3.Call localVarCall = getPatternValidateBeforeCall(getPatternRequest, null);
        Type localVarReturnType = new TypeToken<GetPatternDefaultResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get a pattern definition (asynchronously)
     * Get a pattern definition
     * @param getPatternRequest Get a pattern definition (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getPatternAsync(GetPatternRequest getPatternRequest, final ApiCallback<GetPatternDefaultResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = getPatternValidateBeforeCall(getPatternRequest, _callback);
        Type localVarReturnType = new TypeToken<GetPatternDefaultResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getPatternRecords
     * @param getPatternRecordsRequest Get records from a pattern table (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getPatternRecordsCall(GetPatternRecordsRequest getPatternRecordsRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = getPatternRecordsRequest;

        // create path and map variables
        String localVarPath = "/GetPatternRecords";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "TokenAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getPatternRecordsValidateBeforeCall(GetPatternRecordsRequest getPatternRecordsRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'getPatternRecordsRequest' is set
        if (getPatternRecordsRequest == null) {
            throw new ApiException("Missing the required parameter 'getPatternRecordsRequest' when calling getPatternRecords(Async)");
        }

        return getPatternRecordsCall(getPatternRecordsRequest, _callback);

    }

    /**
     * Get records from a pattern table
     * Get records from a pattern table
     * @param getPatternRecordsRequest Get records from a pattern table (required)
     * @return GetEventRecordsDefaultResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public GetEventRecordsDefaultResponse getPatternRecords(GetPatternRecordsRequest getPatternRecordsRequest) throws ApiException {
        ApiResponse<GetEventRecordsDefaultResponse> localVarResp = getPatternRecordsWithHttpInfo(getPatternRecordsRequest);
        return localVarResp.getData();
    }

    /**
     * Get records from a pattern table
     * Get records from a pattern table
     * @param getPatternRecordsRequest Get records from a pattern table (required)
     * @return ApiResponse&lt;GetEventRecordsDefaultResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<GetEventRecordsDefaultResponse> getPatternRecordsWithHttpInfo(GetPatternRecordsRequest getPatternRecordsRequest) throws ApiException {
        okhttp3.Call localVarCall = getPatternRecordsValidateBeforeCall(getPatternRecordsRequest, null);
        Type localVarReturnType = new TypeToken<GetEventRecordsDefaultResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get records from a pattern table (asynchronously)
     * Get records from a pattern table
     * @param getPatternRecordsRequest Get records from a pattern table (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getPatternRecordsAsync(GetPatternRecordsRequest getPatternRecordsRequest, final ApiCallback<GetEventRecordsDefaultResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = getPatternRecordsValidateBeforeCall(getPatternRecordsRequest, _callback);
        Type localVarReturnType = new TypeToken<GetEventRecordsDefaultResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getPatternTasks
     * @param getPatternTasksRequest Check on the status of pattern tasks (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getPatternTasksCall(GetPatternTasksRequest getPatternTasksRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = getPatternTasksRequest;

        // create path and map variables
        String localVarPath = "/GetPatternTasks";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "TokenAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getPatternTasksValidateBeforeCall(GetPatternTasksRequest getPatternTasksRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'getPatternTasksRequest' is set
        if (getPatternTasksRequest == null) {
            throw new ApiException("Missing the required parameter 'getPatternTasksRequest' when calling getPatternTasks(Async)");
        }

        return getPatternTasksCall(getPatternTasksRequest, _callback);

    }

    /**
     * Check on the status of pattern tasks
     * Check on the status of pattern tasks
     * @param getPatternTasksRequest Check on the status of pattern tasks (required)
     * @return CreatePatternTasksDefaultResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public CreatePatternTasksDefaultResponse getPatternTasks(GetPatternTasksRequest getPatternTasksRequest) throws ApiException {
        ApiResponse<CreatePatternTasksDefaultResponse> localVarResp = getPatternTasksWithHttpInfo(getPatternTasksRequest);
        return localVarResp.getData();
    }

    /**
     * Check on the status of pattern tasks
     * Check on the status of pattern tasks
     * @param getPatternTasksRequest Check on the status of pattern tasks (required)
     * @return ApiResponse&lt;CreatePatternTasksDefaultResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<CreatePatternTasksDefaultResponse> getPatternTasksWithHttpInfo(GetPatternTasksRequest getPatternTasksRequest) throws ApiException {
        okhttp3.Call localVarCall = getPatternTasksValidateBeforeCall(getPatternTasksRequest, null);
        Type localVarReturnType = new TypeToken<CreatePatternTasksDefaultResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Check on the status of pattern tasks (asynchronously)
     * Check on the status of pattern tasks
     * @param getPatternTasksRequest Check on the status of pattern tasks (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getPatternTasksAsync(GetPatternTasksRequest getPatternTasksRequest, final ApiCallback<CreatePatternTasksDefaultResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = getPatternTasksValidateBeforeCall(getPatternTasksRequest, _callback);
        Type localVarReturnType = new TypeToken<CreatePatternTasksDefaultResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getPatterns
     * @param getPatternsRequest Get one or more pattern definitions (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getPatternsCall(GetPatternsRequest getPatternsRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = getPatternsRequest;

        // create path and map variables
        String localVarPath = "/GetPatterns";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "TokenAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getPatternsValidateBeforeCall(GetPatternsRequest getPatternsRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'getPatternsRequest' is set
        if (getPatternsRequest == null) {
            throw new ApiException("Missing the required parameter 'getPatternsRequest' when calling getPatterns(Async)");
        }

        return getPatternsCall(getPatternsRequest, _callback);

    }

    /**
     * Get one or more pattern definitions
     * Get one or more pattern definitions
     * @param getPatternsRequest Get one or more pattern definitions (required)
     * @return GetPatternsDefaultResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public GetPatternsDefaultResponse getPatterns(GetPatternsRequest getPatternsRequest) throws ApiException {
        ApiResponse<GetPatternsDefaultResponse> localVarResp = getPatternsWithHttpInfo(getPatternsRequest);
        return localVarResp.getData();
    }

    /**
     * Get one or more pattern definitions
     * Get one or more pattern definitions
     * @param getPatternsRequest Get one or more pattern definitions (required)
     * @return ApiResponse&lt;GetPatternsDefaultResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<GetPatternsDefaultResponse> getPatternsWithHttpInfo(GetPatternsRequest getPatternsRequest) throws ApiException {
        okhttp3.Call localVarCall = getPatternsValidateBeforeCall(getPatternsRequest, null);
        Type localVarReturnType = new TypeToken<GetPatternsDefaultResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get one or more pattern definitions (asynchronously)
     * Get one or more pattern definitions
     * @param getPatternsRequest Get one or more pattern definitions (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getPatternsAsync(GetPatternsRequest getPatternsRequest, final ApiCallback<GetPatternsDefaultResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = getPatternsValidateBeforeCall(getPatternsRequest, _callback);
        Type localVarReturnType = new TypeToken<GetPatternsDefaultResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getRepeatingPatternItemScores
     * @param getRepeatingPatternItemScoresRequest Gets the scores recorded against the underlying sequence items that are composed into patterns             Currently unscored items are returned with a zero score             Scores can either be recorded directly onto the Item labels themselves or they can be applied to the target labels (e.g. Journeys) that correspond to a specified decode &#39;alias&#39; transform that has been published to the pattern             and sits along-side the sequence item data (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getRepeatingPatternItemScoresCall(GetRepeatingPatternItemScoresRequest getRepeatingPatternItemScoresRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = getRepeatingPatternItemScoresRequest;

        // create path and map variables
        String localVarPath = "/GetRepeatingPatternItemScores";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "TokenAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getRepeatingPatternItemScoresValidateBeforeCall(GetRepeatingPatternItemScoresRequest getRepeatingPatternItemScoresRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'getRepeatingPatternItemScoresRequest' is set
        if (getRepeatingPatternItemScoresRequest == null) {
            throw new ApiException("Missing the required parameter 'getRepeatingPatternItemScoresRequest' when calling getRepeatingPatternItemScores(Async)");
        }

        return getRepeatingPatternItemScoresCall(getRepeatingPatternItemScoresRequest, _callback);

    }

    /**
     * Gets the scores recorded against the underlying sequence items that are composed into patterns             Currently unscored items are returned with a zero score             Scores can either be recorded directly onto the Item labels themselves or they can be applied to the target labels (e.g. Journeys) that correspond to a specified decode &#39;alias&#39; transform that has been published to the pattern             and sits along-side the sequence item data
     * Gets the scores recorded against the underlying sequence items that are composed into patterns             Currently unscored items are returned with a zero score             Scores can either be recorded directly onto the Item labels themselves or they can be applied to the target labels (e.g. Journeys) that correspond to a specified decode &#39;alias&#39; transform that has been published to the pattern             and sits along-side the sequence item data
     * @param getRepeatingPatternItemScoresRequest Gets the scores recorded against the underlying sequence items that are composed into patterns             Currently unscored items are returned with a zero score             Scores can either be recorded directly onto the Item labels themselves or they can be applied to the target labels (e.g. Journeys) that correspond to a specified decode &#39;alias&#39; transform that has been published to the pattern             and sits along-side the sequence item data (required)
     * @return GetRepeatingPatternItemScoresDefaultResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public GetRepeatingPatternItemScoresDefaultResponse getRepeatingPatternItemScores(GetRepeatingPatternItemScoresRequest getRepeatingPatternItemScoresRequest) throws ApiException {
        ApiResponse<GetRepeatingPatternItemScoresDefaultResponse> localVarResp = getRepeatingPatternItemScoresWithHttpInfo(getRepeatingPatternItemScoresRequest);
        return localVarResp.getData();
    }

    /**
     * Gets the scores recorded against the underlying sequence items that are composed into patterns             Currently unscored items are returned with a zero score             Scores can either be recorded directly onto the Item labels themselves or they can be applied to the target labels (e.g. Journeys) that correspond to a specified decode &#39;alias&#39; transform that has been published to the pattern             and sits along-side the sequence item data
     * Gets the scores recorded against the underlying sequence items that are composed into patterns             Currently unscored items are returned with a zero score             Scores can either be recorded directly onto the Item labels themselves or they can be applied to the target labels (e.g. Journeys) that correspond to a specified decode &#39;alias&#39; transform that has been published to the pattern             and sits along-side the sequence item data
     * @param getRepeatingPatternItemScoresRequest Gets the scores recorded against the underlying sequence items that are composed into patterns             Currently unscored items are returned with a zero score             Scores can either be recorded directly onto the Item labels themselves or they can be applied to the target labels (e.g. Journeys) that correspond to a specified decode &#39;alias&#39; transform that has been published to the pattern             and sits along-side the sequence item data (required)
     * @return ApiResponse&lt;GetRepeatingPatternItemScoresDefaultResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<GetRepeatingPatternItemScoresDefaultResponse> getRepeatingPatternItemScoresWithHttpInfo(GetRepeatingPatternItemScoresRequest getRepeatingPatternItemScoresRequest) throws ApiException {
        okhttp3.Call localVarCall = getRepeatingPatternItemScoresValidateBeforeCall(getRepeatingPatternItemScoresRequest, null);
        Type localVarReturnType = new TypeToken<GetRepeatingPatternItemScoresDefaultResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Gets the scores recorded against the underlying sequence items that are composed into patterns             Currently unscored items are returned with a zero score             Scores can either be recorded directly onto the Item labels themselves or they can be applied to the target labels (e.g. Journeys) that correspond to a specified decode &#39;alias&#39; transform that has been published to the pattern             and sits along-side the sequence item data (asynchronously)
     * Gets the scores recorded against the underlying sequence items that are composed into patterns             Currently unscored items are returned with a zero score             Scores can either be recorded directly onto the Item labels themselves or they can be applied to the target labels (e.g. Journeys) that correspond to a specified decode &#39;alias&#39; transform that has been published to the pattern             and sits along-side the sequence item data
     * @param getRepeatingPatternItemScoresRequest Gets the scores recorded against the underlying sequence items that are composed into patterns             Currently unscored items are returned with a zero score             Scores can either be recorded directly onto the Item labels themselves or they can be applied to the target labels (e.g. Journeys) that correspond to a specified decode &#39;alias&#39; transform that has been published to the pattern             and sits along-side the sequence item data (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getRepeatingPatternItemScoresAsync(GetRepeatingPatternItemScoresRequest getRepeatingPatternItemScoresRequest, final ApiCallback<GetRepeatingPatternItemScoresDefaultResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = getRepeatingPatternItemScoresValidateBeforeCall(getRepeatingPatternItemScoresRequest, _callback);
        Type localVarReturnType = new TypeToken<GetRepeatingPatternItemScoresDefaultResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getRepeatingPatternItems
     * @param getRepeatingPatternItemsRequest Gets the underlying sequence items that can be composed into patterns along with any scores that have been used to calculate the MSI (direct or via decodes)             Initially, this will be all the distinct sequence items in the table             Once a pattern has been calculated and uploaded this will be filtered down to only those sequence items that appear in a pattern (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getRepeatingPatternItemsCall(GetRepeatingPatternItemsRequest getRepeatingPatternItemsRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = getRepeatingPatternItemsRequest;

        // create path and map variables
        String localVarPath = "/GetRepeatingPatternItems";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "TokenAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getRepeatingPatternItemsValidateBeforeCall(GetRepeatingPatternItemsRequest getRepeatingPatternItemsRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'getRepeatingPatternItemsRequest' is set
        if (getRepeatingPatternItemsRequest == null) {
            throw new ApiException("Missing the required parameter 'getRepeatingPatternItemsRequest' when calling getRepeatingPatternItems(Async)");
        }

        return getRepeatingPatternItemsCall(getRepeatingPatternItemsRequest, _callback);

    }

    /**
     * Gets the underlying sequence items that can be composed into patterns along with any scores that have been used to calculate the MSI (direct or via decodes)             Initially, this will be all the distinct sequence items in the table             Once a pattern has been calculated and uploaded this will be filtered down to only those sequence items that appear in a pattern
     * Gets the underlying sequence items that can be composed into patterns along with any scores that have been used to calculate the MSI (direct or via decodes)             Initially, this will be all the distinct sequence items in the table             Once a pattern has been calculated and uploaded this will be filtered down to only those sequence items that appear in a pattern
     * @param getRepeatingPatternItemsRequest Gets the underlying sequence items that can be composed into patterns along with any scores that have been used to calculate the MSI (direct or via decodes)             Initially, this will be all the distinct sequence items in the table             Once a pattern has been calculated and uploaded this will be filtered down to only those sequence items that appear in a pattern (required)
     * @return GetEventRecordsDefaultResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public GetEventRecordsDefaultResponse getRepeatingPatternItems(GetRepeatingPatternItemsRequest getRepeatingPatternItemsRequest) throws ApiException {
        ApiResponse<GetEventRecordsDefaultResponse> localVarResp = getRepeatingPatternItemsWithHttpInfo(getRepeatingPatternItemsRequest);
        return localVarResp.getData();
    }

    /**
     * Gets the underlying sequence items that can be composed into patterns along with any scores that have been used to calculate the MSI (direct or via decodes)             Initially, this will be all the distinct sequence items in the table             Once a pattern has been calculated and uploaded this will be filtered down to only those sequence items that appear in a pattern
     * Gets the underlying sequence items that can be composed into patterns along with any scores that have been used to calculate the MSI (direct or via decodes)             Initially, this will be all the distinct sequence items in the table             Once a pattern has been calculated and uploaded this will be filtered down to only those sequence items that appear in a pattern
     * @param getRepeatingPatternItemsRequest Gets the underlying sequence items that can be composed into patterns along with any scores that have been used to calculate the MSI (direct or via decodes)             Initially, this will be all the distinct sequence items in the table             Once a pattern has been calculated and uploaded this will be filtered down to only those sequence items that appear in a pattern (required)
     * @return ApiResponse&lt;GetEventRecordsDefaultResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<GetEventRecordsDefaultResponse> getRepeatingPatternItemsWithHttpInfo(GetRepeatingPatternItemsRequest getRepeatingPatternItemsRequest) throws ApiException {
        okhttp3.Call localVarCall = getRepeatingPatternItemsValidateBeforeCall(getRepeatingPatternItemsRequest, null);
        Type localVarReturnType = new TypeToken<GetEventRecordsDefaultResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Gets the underlying sequence items that can be composed into patterns along with any scores that have been used to calculate the MSI (direct or via decodes)             Initially, this will be all the distinct sequence items in the table             Once a pattern has been calculated and uploaded this will be filtered down to only those sequence items that appear in a pattern (asynchronously)
     * Gets the underlying sequence items that can be composed into patterns along with any scores that have been used to calculate the MSI (direct or via decodes)             Initially, this will be all the distinct sequence items in the table             Once a pattern has been calculated and uploaded this will be filtered down to only those sequence items that appear in a pattern
     * @param getRepeatingPatternItemsRequest Gets the underlying sequence items that can be composed into patterns along with any scores that have been used to calculate the MSI (direct or via decodes)             Initially, this will be all the distinct sequence items in the table             Once a pattern has been calculated and uploaded this will be filtered down to only those sequence items that appear in a pattern (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getRepeatingPatternItemsAsync(GetRepeatingPatternItemsRequest getRepeatingPatternItemsRequest, final ApiCallback<GetEventRecordsDefaultResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = getRepeatingPatternItemsValidateBeforeCall(getRepeatingPatternItemsRequest, _callback);
        Type localVarReturnType = new TypeToken<GetEventRecordsDefaultResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for requestCancelPatternTasks
     * @param requestCancelPatternTasksRequest Requests cancellation of all tasks for a pattern. This may take some time to be actioned if the tasks are already running (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call requestCancelPatternTasksCall(RequestCancelPatternTasksRequest requestCancelPatternTasksRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = requestCancelPatternTasksRequest;

        // create path and map variables
        String localVarPath = "/RequestCancelPatternTasks";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "TokenAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call requestCancelPatternTasksValidateBeforeCall(RequestCancelPatternTasksRequest requestCancelPatternTasksRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'requestCancelPatternTasksRequest' is set
        if (requestCancelPatternTasksRequest == null) {
            throw new ApiException("Missing the required parameter 'requestCancelPatternTasksRequest' when calling requestCancelPatternTasks(Async)");
        }

        return requestCancelPatternTasksCall(requestCancelPatternTasksRequest, _callback);

    }

    /**
     * Requests cancellation of all tasks for a pattern. This may take some time to be actioned if the tasks are already running
     * Requests cancellation of all tasks for a pattern. This may take some time to be actioned if the tasks are already running
     * @param requestCancelPatternTasksRequest Requests cancellation of all tasks for a pattern. This may take some time to be actioned if the tasks are already running (required)
     * @return AUTHChangePasswordDefaultResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public AUTHChangePasswordDefaultResponse requestCancelPatternTasks(RequestCancelPatternTasksRequest requestCancelPatternTasksRequest) throws ApiException {
        ApiResponse<AUTHChangePasswordDefaultResponse> localVarResp = requestCancelPatternTasksWithHttpInfo(requestCancelPatternTasksRequest);
        return localVarResp.getData();
    }

    /**
     * Requests cancellation of all tasks for a pattern. This may take some time to be actioned if the tasks are already running
     * Requests cancellation of all tasks for a pattern. This may take some time to be actioned if the tasks are already running
     * @param requestCancelPatternTasksRequest Requests cancellation of all tasks for a pattern. This may take some time to be actioned if the tasks are already running (required)
     * @return ApiResponse&lt;AUTHChangePasswordDefaultResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<AUTHChangePasswordDefaultResponse> requestCancelPatternTasksWithHttpInfo(RequestCancelPatternTasksRequest requestCancelPatternTasksRequest) throws ApiException {
        okhttp3.Call localVarCall = requestCancelPatternTasksValidateBeforeCall(requestCancelPatternTasksRequest, null);
        Type localVarReturnType = new TypeToken<AUTHChangePasswordDefaultResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Requests cancellation of all tasks for a pattern. This may take some time to be actioned if the tasks are already running (asynchronously)
     * Requests cancellation of all tasks for a pattern. This may take some time to be actioned if the tasks are already running
     * @param requestCancelPatternTasksRequest Requests cancellation of all tasks for a pattern. This may take some time to be actioned if the tasks are already running (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call requestCancelPatternTasksAsync(RequestCancelPatternTasksRequest requestCancelPatternTasksRequest, final ApiCallback<AUTHChangePasswordDefaultResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = requestCancelPatternTasksValidateBeforeCall(requestCancelPatternTasksRequest, _callback);
        Type localVarReturnType = new TypeToken<AUTHChangePasswordDefaultResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for updatePattern
     * @param updatePatternRequest Updates a Pattern definition. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call updatePatternCall(UpdatePatternRequest updatePatternRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = updatePatternRequest;

        // create path and map variables
        String localVarPath = "/UpdatePattern";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "TokenAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call updatePatternValidateBeforeCall(UpdatePatternRequest updatePatternRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'updatePatternRequest' is set
        if (updatePatternRequest == null) {
            throw new ApiException("Missing the required parameter 'updatePatternRequest' when calling updatePattern(Async)");
        }

        return updatePatternCall(updatePatternRequest, _callback);

    }

    /**
     * Updates a Pattern definition.
     * Updates a Pattern definition.
     * @param updatePatternRequest Updates a Pattern definition. (required)
     * @return AUTHChangePasswordDefaultResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public AUTHChangePasswordDefaultResponse updatePattern(UpdatePatternRequest updatePatternRequest) throws ApiException {
        ApiResponse<AUTHChangePasswordDefaultResponse> localVarResp = updatePatternWithHttpInfo(updatePatternRequest);
        return localVarResp.getData();
    }

    /**
     * Updates a Pattern definition.
     * Updates a Pattern definition.
     * @param updatePatternRequest Updates a Pattern definition. (required)
     * @return ApiResponse&lt;AUTHChangePasswordDefaultResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<AUTHChangePasswordDefaultResponse> updatePatternWithHttpInfo(UpdatePatternRequest updatePatternRequest) throws ApiException {
        okhttp3.Call localVarCall = updatePatternValidateBeforeCall(updatePatternRequest, null);
        Type localVarReturnType = new TypeToken<AUTHChangePasswordDefaultResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Updates a Pattern definition. (asynchronously)
     * Updates a Pattern definition.
     * @param updatePatternRequest Updates a Pattern definition. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call updatePatternAsync(UpdatePatternRequest updatePatternRequest, final ApiCallback<AUTHChangePasswordDefaultResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = updatePatternValidateBeforeCall(updatePatternRequest, _callback);
        Type localVarReturnType = new TypeToken<AUTHChangePasswordDefaultResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for updateRepeatingPatternItemScores
     * @param updateRepeatingPatternItemScoresRequest Update one or more of the scores maintained against the underlying sequence item labels that are composed into patterns             Scores can either be recorded directly onto the Item labels themselves or they can be applied to the target labels (e.g. Journeys) that correspond to a specified &#39;alias&#39; transform that sits along-side the sequence item data             Only one such decode alias can be scored at a time and when scores are applied they are applied from the alias first and then overridden with any score that has been stored againt the items themselves             If the scores are to be applied against a decode then its id and version must be specified             The scores are intended to denote the relative importance of items in a sequence. The label of the item with the highest score will serve as the overall label (MSI) for the sequence             Specifying zero for a score is the only way of &#39;unscoring&#39; it at present (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call updateRepeatingPatternItemScoresCall(UpdateRepeatingPatternItemScoresRequest updateRepeatingPatternItemScoresRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = updateRepeatingPatternItemScoresRequest;

        // create path and map variables
        String localVarPath = "/UpdateRepeatingPatternItemScores";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "TokenAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call updateRepeatingPatternItemScoresValidateBeforeCall(UpdateRepeatingPatternItemScoresRequest updateRepeatingPatternItemScoresRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'updateRepeatingPatternItemScoresRequest' is set
        if (updateRepeatingPatternItemScoresRequest == null) {
            throw new ApiException("Missing the required parameter 'updateRepeatingPatternItemScoresRequest' when calling updateRepeatingPatternItemScores(Async)");
        }

        return updateRepeatingPatternItemScoresCall(updateRepeatingPatternItemScoresRequest, _callback);

    }

    /**
     * Update one or more of the scores maintained against the underlying sequence item labels that are composed into patterns             Scores can either be recorded directly onto the Item labels themselves or they can be applied to the target labels (e.g. Journeys) that correspond to a specified &#39;alias&#39; transform that sits along-side the sequence item data             Only one such decode alias can be scored at a time and when scores are applied they are applied from the alias first and then overridden with any score that has been stored againt the items themselves             If the scores are to be applied against a decode then its id and version must be specified             The scores are intended to denote the relative importance of items in a sequence. The label of the item with the highest score will serve as the overall label (MSI) for the sequence             Specifying zero for a score is the only way of &#39;unscoring&#39; it at present
     * Update one or more of the scores maintained against the underlying sequence item labels that are composed into patterns             Scores can either be recorded directly onto the Item labels themselves or they can be applied to the target labels (e.g. Journeys) that correspond to a specified &#39;alias&#39; transform that sits along-side the sequence item data             Only one such decode alias can be scored at a time and when scores are applied they are applied from the alias first and then overridden with any score that has been stored againt the items themselves             If the scores are to be applied against a decode then its id and version must be specified             The scores are intended to denote the relative importance of items in a sequence. The label of the item with the highest score will serve as the overall label (MSI) for the sequence             Specifying zero for a score is the only way of &#39;unscoring&#39; it at present
     * @param updateRepeatingPatternItemScoresRequest Update one or more of the scores maintained against the underlying sequence item labels that are composed into patterns             Scores can either be recorded directly onto the Item labels themselves or they can be applied to the target labels (e.g. Journeys) that correspond to a specified &#39;alias&#39; transform that sits along-side the sequence item data             Only one such decode alias can be scored at a time and when scores are applied they are applied from the alias first and then overridden with any score that has been stored againt the items themselves             If the scores are to be applied against a decode then its id and version must be specified             The scores are intended to denote the relative importance of items in a sequence. The label of the item with the highest score will serve as the overall label (MSI) for the sequence             Specifying zero for a score is the only way of &#39;unscoring&#39; it at present (required)
     * @return AUTHChangePasswordDefaultResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public AUTHChangePasswordDefaultResponse updateRepeatingPatternItemScores(UpdateRepeatingPatternItemScoresRequest updateRepeatingPatternItemScoresRequest) throws ApiException {
        ApiResponse<AUTHChangePasswordDefaultResponse> localVarResp = updateRepeatingPatternItemScoresWithHttpInfo(updateRepeatingPatternItemScoresRequest);
        return localVarResp.getData();
    }

    /**
     * Update one or more of the scores maintained against the underlying sequence item labels that are composed into patterns             Scores can either be recorded directly onto the Item labels themselves or they can be applied to the target labels (e.g. Journeys) that correspond to a specified &#39;alias&#39; transform that sits along-side the sequence item data             Only one such decode alias can be scored at a time and when scores are applied they are applied from the alias first and then overridden with any score that has been stored againt the items themselves             If the scores are to be applied against a decode then its id and version must be specified             The scores are intended to denote the relative importance of items in a sequence. The label of the item with the highest score will serve as the overall label (MSI) for the sequence             Specifying zero for a score is the only way of &#39;unscoring&#39; it at present
     * Update one or more of the scores maintained against the underlying sequence item labels that are composed into patterns             Scores can either be recorded directly onto the Item labels themselves or they can be applied to the target labels (e.g. Journeys) that correspond to a specified &#39;alias&#39; transform that sits along-side the sequence item data             Only one such decode alias can be scored at a time and when scores are applied they are applied from the alias first and then overridden with any score that has been stored againt the items themselves             If the scores are to be applied against a decode then its id and version must be specified             The scores are intended to denote the relative importance of items in a sequence. The label of the item with the highest score will serve as the overall label (MSI) for the sequence             Specifying zero for a score is the only way of &#39;unscoring&#39; it at present
     * @param updateRepeatingPatternItemScoresRequest Update one or more of the scores maintained against the underlying sequence item labels that are composed into patterns             Scores can either be recorded directly onto the Item labels themselves or they can be applied to the target labels (e.g. Journeys) that correspond to a specified &#39;alias&#39; transform that sits along-side the sequence item data             Only one such decode alias can be scored at a time and when scores are applied they are applied from the alias first and then overridden with any score that has been stored againt the items themselves             If the scores are to be applied against a decode then its id and version must be specified             The scores are intended to denote the relative importance of items in a sequence. The label of the item with the highest score will serve as the overall label (MSI) for the sequence             Specifying zero for a score is the only way of &#39;unscoring&#39; it at present (required)
     * @return ApiResponse&lt;AUTHChangePasswordDefaultResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<AUTHChangePasswordDefaultResponse> updateRepeatingPatternItemScoresWithHttpInfo(UpdateRepeatingPatternItemScoresRequest updateRepeatingPatternItemScoresRequest) throws ApiException {
        okhttp3.Call localVarCall = updateRepeatingPatternItemScoresValidateBeforeCall(updateRepeatingPatternItemScoresRequest, null);
        Type localVarReturnType = new TypeToken<AUTHChangePasswordDefaultResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Update one or more of the scores maintained against the underlying sequence item labels that are composed into patterns             Scores can either be recorded directly onto the Item labels themselves or they can be applied to the target labels (e.g. Journeys) that correspond to a specified &#39;alias&#39; transform that sits along-side the sequence item data             Only one such decode alias can be scored at a time and when scores are applied they are applied from the alias first and then overridden with any score that has been stored againt the items themselves             If the scores are to be applied against a decode then its id and version must be specified             The scores are intended to denote the relative importance of items in a sequence. The label of the item with the highest score will serve as the overall label (MSI) for the sequence             Specifying zero for a score is the only way of &#39;unscoring&#39; it at present (asynchronously)
     * Update one or more of the scores maintained against the underlying sequence item labels that are composed into patterns             Scores can either be recorded directly onto the Item labels themselves or they can be applied to the target labels (e.g. Journeys) that correspond to a specified &#39;alias&#39; transform that sits along-side the sequence item data             Only one such decode alias can be scored at a time and when scores are applied they are applied from the alias first and then overridden with any score that has been stored againt the items themselves             If the scores are to be applied against a decode then its id and version must be specified             The scores are intended to denote the relative importance of items in a sequence. The label of the item with the highest score will serve as the overall label (MSI) for the sequence             Specifying zero for a score is the only way of &#39;unscoring&#39; it at present
     * @param updateRepeatingPatternItemScoresRequest Update one or more of the scores maintained against the underlying sequence item labels that are composed into patterns             Scores can either be recorded directly onto the Item labels themselves or they can be applied to the target labels (e.g. Journeys) that correspond to a specified &#39;alias&#39; transform that sits along-side the sequence item data             Only one such decode alias can be scored at a time and when scores are applied they are applied from the alias first and then overridden with any score that has been stored againt the items themselves             If the scores are to be applied against a decode then its id and version must be specified             The scores are intended to denote the relative importance of items in a sequence. The label of the item with the highest score will serve as the overall label (MSI) for the sequence             Specifying zero for a score is the only way of &#39;unscoring&#39; it at present (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 0 </td><td> Success </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call updateRepeatingPatternItemScoresAsync(UpdateRepeatingPatternItemScoresRequest updateRepeatingPatternItemScoresRequest, final ApiCallback<AUTHChangePasswordDefaultResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = updateRepeatingPatternItemScoresValidateBeforeCall(updateRepeatingPatternItemScoresRequest, _callback);
        Type localVarReturnType = new TypeToken<AUTHChangePasswordDefaultResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
}
