/*
 * Journey Analytics API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 6.35.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.alterian.ja.model;

import java.util.Objects;
import com.alterian.ja.model.APICursor;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.jackson.nullable.JsonNullable;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import com.alterian.ja.JSON;

/**
 * GetEventStreamDecodeMappingsRequest
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", comments = "Generator version: 7.4.0")
public class GetEventStreamDecodeMappingsRequest {
  public static final String SERIALIZED_NAME_BASE_LIST_ID = "BaseListId";
  @SerializedName(SERIALIZED_NAME_BASE_LIST_ID)
  private Integer baseListId;

  public static final String SERIALIZED_NAME_BASE_LIST_VERSION = "BaseListVersion";
  @SerializedName(SERIALIZED_NAME_BASE_LIST_VERSION)
  private Integer baseListVersion;

  public static final String SERIALIZED_NAME_COLUMN_NAME = "ColumnName";
  @SerializedName(SERIALIZED_NAME_COLUMN_NAME)
  private String columnName;

  public static final String SERIALIZED_NAME_CURSOR = "Cursor";
  @SerializedName(SERIALIZED_NAME_CURSOR)
  private APICursor cursor;

  public static final String SERIALIZED_NAME_DEFAULT_LABEL = "DefaultLabel";
  @SerializedName(SERIALIZED_NAME_DEFAULT_LABEL)
  private String defaultLabel;

  public static final String SERIALIZED_NAME_EVENT_DATE_TIME_LOWER = "EventDateTimeLower";
  @SerializedName(SERIALIZED_NAME_EVENT_DATE_TIME_LOWER)
  private OffsetDateTime eventDateTimeLower;

  public static final String SERIALIZED_NAME_EVENT_DATE_TIME_UPPER = "EventDateTimeUpper";
  @SerializedName(SERIALIZED_NAME_EVENT_DATE_TIME_UPPER)
  private OffsetDateTime eventDateTimeUpper;

  public static final String SERIALIZED_NAME_EVENT_STREAM_ID = "EventStreamId";
  @SerializedName(SERIALIZED_NAME_EVENT_STREAM_ID)
  private Integer eventStreamId;

  public static final String SERIALIZED_NAME_INCLUDE_MAPPINGS_MISSING_FROM_SAMPLE = "IncludeMappingsMissingFromSample";
  @SerializedName(SERIALIZED_NAME_INCLUDE_MAPPINGS_MISSING_FROM_SAMPLE)
  private Boolean includeMappingsMissingFromSample;

  public static final String SERIALIZED_NAME_IS_DATA_REFRESH_REQUIRED = "IsDataRefreshRequired";
  @SerializedName(SERIALIZED_NAME_IS_DATA_REFRESH_REQUIRED)
  private Boolean isDataRefreshRequired;

  public static final String SERIALIZED_NAME_IS_DEFAULT_LABEL_CONFIGURED = "IsDefaultLabelConfigured";
  @SerializedName(SERIALIZED_NAME_IS_DEFAULT_LABEL_CONFIGURED)
  private Boolean isDefaultLabelConfigured;

  public static final String SERIALIZED_NAME_SOURCE_LABELS = "SourceLabels";
  @SerializedName(SERIALIZED_NAME_SOURCE_LABELS)
  private List<String> sourceLabels;

  public static final String SERIALIZED_NAME_SOURCE_LABEL_SEARCH = "SourceLabelSearch";
  @SerializedName(SERIALIZED_NAME_SOURCE_LABEL_SEARCH)
  private String sourceLabelSearch;

  public static final String SERIALIZED_NAME_TARGET_LABEL_MATCH_LIST = "TargetLabelMatchList";
  @SerializedName(SERIALIZED_NAME_TARGET_LABEL_MATCH_LIST)
  private List<String> targetLabelMatchList;

  public static final String SERIALIZED_NAME_TARGET_LABELS = "TargetLabels";
  @SerializedName(SERIALIZED_NAME_TARGET_LABELS)
  private List<String> targetLabels;

  public GetEventStreamDecodeMappingsRequest() {
  }

  public GetEventStreamDecodeMappingsRequest baseListId(Integer baseListId) {
    this.baseListId = baseListId;
    return this;
  }

   /**
   * Optionally base the decodes on a specified decode list subject to any explicitly specified overrides
   * @return baseListId
  **/
  @javax.annotation.Nullable
  public Integer getBaseListId() {
    return baseListId;
  }

  public void setBaseListId(Integer baseListId) {
    this.baseListId = baseListId;
  }


  public GetEventStreamDecodeMappingsRequest baseListVersion(Integer baseListVersion) {
    this.baseListVersion = baseListVersion;
    return this;
  }

   /**
   * Optional list version (defaults to latest)
   * @return baseListVersion
  **/
  @javax.annotation.Nullable
  public Integer getBaseListVersion() {
    return baseListVersion;
  }

  public void setBaseListVersion(Integer baseListVersion) {
    this.baseListVersion = baseListVersion;
  }


  public GetEventStreamDecodeMappingsRequest columnName(String columnName) {
    this.columnName = columnName;
    return this;
  }

   /**
   * Column from the event stream to be decoded (defaults to Location)
   * @return columnName
  **/
  @javax.annotation.Nullable
  public String getColumnName() {
    return columnName;
  }

  public void setColumnName(String columnName) {
    this.columnName = columnName;
  }


  public GetEventStreamDecodeMappingsRequest cursor(APICursor cursor) {
    this.cursor = cursor;
    return this;
  }

   /**
   * Get cursor
   * @return cursor
  **/
  @javax.annotation.Nullable
  public APICursor getCursor() {
    return cursor;
  }

  public void setCursor(APICursor cursor) {
    this.cursor = cursor;
  }


  public GetEventStreamDecodeMappingsRequest defaultLabel(String defaultLabel) {
    this.defaultLabel = defaultLabel;
    return this;
  }

   /**
   * In conjunction with IsDefaultLabelConfigured this allows the API to override the default label from any specified base decode list. Pass NULL to remove an underlying list default and an empty string or space to override it to NULL
   * @return defaultLabel
  **/
  @javax.annotation.Nullable
  public String getDefaultLabel() {
    return defaultLabel;
  }

  public void setDefaultLabel(String defaultLabel) {
    this.defaultLabel = defaultLabel;
  }


  public GetEventStreamDecodeMappingsRequest eventDateTimeLower(OffsetDateTime eventDateTimeLower) {
    this.eventDateTimeLower = eventDateTimeLower;
    return this;
  }

   /**
   * Start of the date window for column values to be displayed and decoded
   * @return eventDateTimeLower
  **/
  @javax.annotation.Nullable
  public OffsetDateTime getEventDateTimeLower() {
    return eventDateTimeLower;
  }

  public void setEventDateTimeLower(OffsetDateTime eventDateTimeLower) {
    this.eventDateTimeLower = eventDateTimeLower;
  }


  public GetEventStreamDecodeMappingsRequest eventDateTimeUpper(OffsetDateTime eventDateTimeUpper) {
    this.eventDateTimeUpper = eventDateTimeUpper;
    return this;
  }

   /**
   * End of the date window for column values to be displayed and decoded
   * @return eventDateTimeUpper
  **/
  @javax.annotation.Nullable
  public OffsetDateTime getEventDateTimeUpper() {
    return eventDateTimeUpper;
  }

  public void setEventDateTimeUpper(OffsetDateTime eventDateTimeUpper) {
    this.eventDateTimeUpper = eventDateTimeUpper;
  }


  public GetEventStreamDecodeMappingsRequest eventStreamId(Integer eventStreamId) {
    this.eventStreamId = eventStreamId;
    return this;
  }

   /**
   * Event Stream Id
   * @return eventStreamId
  **/
  @javax.annotation.Nullable
  public Integer getEventStreamId() {
    return eventStreamId;
  }

  public void setEventStreamId(Integer eventStreamId) {
    this.eventStreamId = eventStreamId;
  }


  public GetEventStreamDecodeMappingsRequest includeMappingsMissingFromSample(Boolean includeMappingsMissingFromSample) {
    this.includeMappingsMissingFromSample = includeMappingsMissingFromSample;
    return this;
  }

   /**
   * When set to true any decodes that have been configured but which do not appear in the sampled data will be included with a zero count
   * @return includeMappingsMissingFromSample
  **/
  @javax.annotation.Nullable
  public Boolean getIncludeMappingsMissingFromSample() {
    return includeMappingsMissingFromSample;
  }

  public void setIncludeMappingsMissingFromSample(Boolean includeMappingsMissingFromSample) {
    this.includeMappingsMissingFromSample = includeMappingsMissingFromSample;
  }


  public GetEventStreamDecodeMappingsRequest isDataRefreshRequired(Boolean isDataRefreshRequired) {
    this.isDataRefreshRequired = isDataRefreshRequired;
    return this;
  }

   /**
   * Force the source labels to be refreshed from the event stream data
   * @return isDataRefreshRequired
  **/
  @javax.annotation.Nullable
  public Boolean getIsDataRefreshRequired() {
    return isDataRefreshRequired;
  }

  public void setIsDataRefreshRequired(Boolean isDataRefreshRequired) {
    this.isDataRefreshRequired = isDataRefreshRequired;
  }


  public GetEventStreamDecodeMappingsRequest isDefaultLabelConfigured(Boolean isDefaultLabelConfigured) {
    this.isDefaultLabelConfigured = isDefaultLabelConfigured;
    return this;
  }

   /**
   * Set this to true if DefaultLabel is being used. If set to false then the default label will be determined by any specified base decode list
   * @return isDefaultLabelConfigured
  **/
  @javax.annotation.Nullable
  public Boolean getIsDefaultLabelConfigured() {
    return isDefaultLabelConfigured;
  }

  public void setIsDefaultLabelConfigured(Boolean isDefaultLabelConfigured) {
    this.isDefaultLabelConfigured = isDefaultLabelConfigured;
  }


  public GetEventStreamDecodeMappingsRequest sourceLabels(List<String> sourceLabels) {
    this.sourceLabels = sourceLabels;
    return this;
  }

  public GetEventStreamDecodeMappingsRequest addSourceLabelsItem(String sourceLabelsItem) {
    if (this.sourceLabels == null) {
      this.sourceLabels = new ArrayList<>();
    }
    this.sourceLabels.add(sourceLabelsItem);
    return this;
  }

   /**
   * Specify any source labels that should be overriden on the specified base decode list
   * @return sourceLabels
  **/
  @javax.annotation.Nullable
  public List<String> getSourceLabels() {
    return sourceLabels;
  }

  public void setSourceLabels(List<String> sourceLabels) {
    this.sourceLabels = sourceLabels;
  }


  public GetEventStreamDecodeMappingsRequest sourceLabelSearch(String sourceLabelSearch) {
    this.sourceLabelSearch = sourceLabelSearch;
    return this;
  }

   /**
   * Filter the result by using search string against the source labels. Search term doesn not required wildcards and is currently case sensitive
   * @return sourceLabelSearch
  **/
  @javax.annotation.Nullable
  public String getSourceLabelSearch() {
    return sourceLabelSearch;
  }

  public void setSourceLabelSearch(String sourceLabelSearch) {
    this.sourceLabelSearch = sourceLabelSearch;
  }


  public GetEventStreamDecodeMappingsRequest targetLabelMatchList(List<String> targetLabelMatchList) {
    this.targetLabelMatchList = targetLabelMatchList;
    return this;
  }

  public GetEventStreamDecodeMappingsRequest addTargetLabelMatchListItem(String targetLabelMatchListItem) {
    if (this.targetLabelMatchList == null) {
      this.targetLabelMatchList = new ArrayList<>();
    }
    this.targetLabelMatchList.add(targetLabelMatchListItem);
    return this;
  }

   /**
   * Filter the result the specified target labels
   * @return targetLabelMatchList
  **/
  @javax.annotation.Nullable
  public List<String> getTargetLabelMatchList() {
    return targetLabelMatchList;
  }

  public void setTargetLabelMatchList(List<String> targetLabelMatchList) {
    this.targetLabelMatchList = targetLabelMatchList;
  }


  public GetEventStreamDecodeMappingsRequest targetLabels(List<String> targetLabels) {
    this.targetLabels = targetLabels;
    return this;
  }

  public GetEventStreamDecodeMappingsRequest addTargetLabelsItem(String targetLabelsItem) {
    if (this.targetLabels == null) {
      this.targetLabels = new ArrayList<>();
    }
    this.targetLabels.add(targetLabelsItem);
    return this;
  }

   /**
   * Specify the target labels that should override the specified base decode list. Pass NULL to remove an underlying list decode or an empty string to override it to NULL. Pass a NULL list to remove mappings for all the specified source labels
   * @return targetLabels
  **/
  @javax.annotation.Nullable
  public List<String> getTargetLabels() {
    return targetLabels;
  }

  public void setTargetLabels(List<String> targetLabels) {
    this.targetLabels = targetLabels;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    GetEventStreamDecodeMappingsRequest getEventStreamDecodeMappingsRequest = (GetEventStreamDecodeMappingsRequest) o;
    return Objects.equals(this.baseListId, getEventStreamDecodeMappingsRequest.baseListId) &&
        Objects.equals(this.baseListVersion, getEventStreamDecodeMappingsRequest.baseListVersion) &&
        Objects.equals(this.columnName, getEventStreamDecodeMappingsRequest.columnName) &&
        Objects.equals(this.cursor, getEventStreamDecodeMappingsRequest.cursor) &&
        Objects.equals(this.defaultLabel, getEventStreamDecodeMappingsRequest.defaultLabel) &&
        Objects.equals(this.eventDateTimeLower, getEventStreamDecodeMappingsRequest.eventDateTimeLower) &&
        Objects.equals(this.eventDateTimeUpper, getEventStreamDecodeMappingsRequest.eventDateTimeUpper) &&
        Objects.equals(this.eventStreamId, getEventStreamDecodeMappingsRequest.eventStreamId) &&
        Objects.equals(this.includeMappingsMissingFromSample, getEventStreamDecodeMappingsRequest.includeMappingsMissingFromSample) &&
        Objects.equals(this.isDataRefreshRequired, getEventStreamDecodeMappingsRequest.isDataRefreshRequired) &&
        Objects.equals(this.isDefaultLabelConfigured, getEventStreamDecodeMappingsRequest.isDefaultLabelConfigured) &&
        Objects.equals(this.sourceLabels, getEventStreamDecodeMappingsRequest.sourceLabels) &&
        Objects.equals(this.sourceLabelSearch, getEventStreamDecodeMappingsRequest.sourceLabelSearch) &&
        Objects.equals(this.targetLabelMatchList, getEventStreamDecodeMappingsRequest.targetLabelMatchList) &&
        Objects.equals(this.targetLabels, getEventStreamDecodeMappingsRequest.targetLabels);
  }

  private static <T> boolean equalsNullable(JsonNullable<T> a, JsonNullable<T> b) {
    return a == b || (a != null && b != null && a.isPresent() && b.isPresent() && Objects.deepEquals(a.get(), b.get()));
  }

  @Override
  public int hashCode() {
    return Objects.hash(baseListId, baseListVersion, columnName, cursor, defaultLabel, eventDateTimeLower, eventDateTimeUpper, eventStreamId, includeMappingsMissingFromSample, isDataRefreshRequired, isDefaultLabelConfigured, sourceLabels, sourceLabelSearch, targetLabelMatchList, targetLabels);
  }

  private static <T> int hashCodeNullable(JsonNullable<T> a) {
    if (a == null) {
      return 1;
    }
    return a.isPresent() ? Arrays.deepHashCode(new Object[]{a.get()}) : 31;
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class GetEventStreamDecodeMappingsRequest {\n");
    sb.append("    baseListId: ").append(toIndentedString(baseListId)).append("\n");
    sb.append("    baseListVersion: ").append(toIndentedString(baseListVersion)).append("\n");
    sb.append("    columnName: ").append(toIndentedString(columnName)).append("\n");
    sb.append("    cursor: ").append(toIndentedString(cursor)).append("\n");
    sb.append("    defaultLabel: ").append(toIndentedString(defaultLabel)).append("\n");
    sb.append("    eventDateTimeLower: ").append(toIndentedString(eventDateTimeLower)).append("\n");
    sb.append("    eventDateTimeUpper: ").append(toIndentedString(eventDateTimeUpper)).append("\n");
    sb.append("    eventStreamId: ").append(toIndentedString(eventStreamId)).append("\n");
    sb.append("    includeMappingsMissingFromSample: ").append(toIndentedString(includeMappingsMissingFromSample)).append("\n");
    sb.append("    isDataRefreshRequired: ").append(toIndentedString(isDataRefreshRequired)).append("\n");
    sb.append("    isDefaultLabelConfigured: ").append(toIndentedString(isDefaultLabelConfigured)).append("\n");
    sb.append("    sourceLabels: ").append(toIndentedString(sourceLabels)).append("\n");
    sb.append("    sourceLabelSearch: ").append(toIndentedString(sourceLabelSearch)).append("\n");
    sb.append("    targetLabelMatchList: ").append(toIndentedString(targetLabelMatchList)).append("\n");
    sb.append("    targetLabels: ").append(toIndentedString(targetLabels)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("BaseListId");
    openapiFields.add("BaseListVersion");
    openapiFields.add("ColumnName");
    openapiFields.add("Cursor");
    openapiFields.add("DefaultLabel");
    openapiFields.add("EventDateTimeLower");
    openapiFields.add("EventDateTimeUpper");
    openapiFields.add("EventStreamId");
    openapiFields.add("IncludeMappingsMissingFromSample");
    openapiFields.add("IsDataRefreshRequired");
    openapiFields.add("IsDefaultLabelConfigured");
    openapiFields.add("SourceLabels");
    openapiFields.add("SourceLabelSearch");
    openapiFields.add("TargetLabelMatchList");
    openapiFields.add("TargetLabels");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

 /**
  * Validates the JSON Element and throws an exception if issues found
  *
  * @param jsonElement JSON Element
  * @throws IOException if the JSON Element is invalid with respect to GetEventStreamDecodeMappingsRequest
  */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!GetEventStreamDecodeMappingsRequest.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in GetEventStreamDecodeMappingsRequest is not found in the empty JSON string", GetEventStreamDecodeMappingsRequest.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!GetEventStreamDecodeMappingsRequest.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `GetEventStreamDecodeMappingsRequest` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("ColumnName") != null && !jsonObj.get("ColumnName").isJsonNull()) && !jsonObj.get("ColumnName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `ColumnName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("ColumnName").toString()));
      }
      // validate the optional field `Cursor`
      if (jsonObj.get("Cursor") != null && !jsonObj.get("Cursor").isJsonNull()) {
        APICursor.validateJsonElement(jsonObj.get("Cursor"));
      }
      if ((jsonObj.get("DefaultLabel") != null && !jsonObj.get("DefaultLabel").isJsonNull()) && !jsonObj.get("DefaultLabel").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `DefaultLabel` to be a primitive type in the JSON string but got `%s`", jsonObj.get("DefaultLabel").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("SourceLabels") != null && !jsonObj.get("SourceLabels").isJsonNull() && !jsonObj.get("SourceLabels").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `SourceLabels` to be an array in the JSON string but got `%s`", jsonObj.get("SourceLabels").toString()));
      }
      if ((jsonObj.get("SourceLabelSearch") != null && !jsonObj.get("SourceLabelSearch").isJsonNull()) && !jsonObj.get("SourceLabelSearch").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `SourceLabelSearch` to be a primitive type in the JSON string but got `%s`", jsonObj.get("SourceLabelSearch").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("TargetLabelMatchList") != null && !jsonObj.get("TargetLabelMatchList").isJsonNull() && !jsonObj.get("TargetLabelMatchList").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `TargetLabelMatchList` to be an array in the JSON string but got `%s`", jsonObj.get("TargetLabelMatchList").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("TargetLabels") != null && !jsonObj.get("TargetLabels").isJsonNull() && !jsonObj.get("TargetLabels").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `TargetLabels` to be an array in the JSON string but got `%s`", jsonObj.get("TargetLabels").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!GetEventStreamDecodeMappingsRequest.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'GetEventStreamDecodeMappingsRequest' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<GetEventStreamDecodeMappingsRequest> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(GetEventStreamDecodeMappingsRequest.class));

       return (TypeAdapter<T>) new TypeAdapter<GetEventStreamDecodeMappingsRequest>() {
           @Override
           public void write(JsonWriter out, GetEventStreamDecodeMappingsRequest value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public GetEventStreamDecodeMappingsRequest read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of GetEventStreamDecodeMappingsRequest given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of GetEventStreamDecodeMappingsRequest
  * @throws IOException if the JSON string is invalid with respect to GetEventStreamDecodeMappingsRequest
  */
  public static GetEventStreamDecodeMappingsRequest fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, GetEventStreamDecodeMappingsRequest.class);
  }

 /**
  * Convert an instance of GetEventStreamDecodeMappingsRequest to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

