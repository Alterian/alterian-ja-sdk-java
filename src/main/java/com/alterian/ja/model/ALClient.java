/*
 * Journey Analytics API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 6.35.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.alterian.ja.model;

import java.util.Objects;
import com.alterian.ja.model.ModelPackage;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import com.alterian.ja.JSON;

/**
 * A client represents a distinct set of users, documents and other data within a system.              Users and documents are unique within a client, and are isolated from other clients, so they cannot be shared between clients (except manually by export and import)             Note that multiple clients can use the same customer data by each creating a @see(ALDataSource) to the same customer database.             Each customer will typically have one client, but some large customers may have multiple clients             Each client has it&#39;s own SQLServer database to store information in.                The data is returned as a @see(ALClient) object
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", comments = "Generator version: 7.4.0")
public class ALClient {
  public static final String SERIALIZED_NAME_I_D = "ID";
  @SerializedName(SERIALIZED_NAME_I_D)
  private Integer ID;

  public static final String SERIALIZED_NAME_NAME = "Name";
  @SerializedName(SERIALIZED_NAME_NAME)
  private String name;

  public static final String SERIALIZED_NAME_ENABLED = "Enabled";
  @SerializedName(SERIALIZED_NAME_ENABLED)
  private Boolean enabled;

  public static final String SERIALIZED_NAME_SETTINGS = "Settings";
  @SerializedName(SERIALIZED_NAME_SETTINGS)
  private Map<String, String> settings = new HashMap<>();

  public static final String SERIALIZED_NAME_PACKAGES = "Packages";
  @SerializedName(SERIALIZED_NAME_PACKAGES)
  private List<ModelPackage> packages;

  public static final String SERIALIZED_NAME_CLIENT_SET_I_D = "ClientSetID";
  @SerializedName(SERIALIZED_NAME_CLIENT_SET_I_D)
  private Integer clientSetID;

  public static final String SERIALIZED_NAME_SITE_ID = "SiteId";
  @SerializedName(SERIALIZED_NAME_SITE_ID)
  private UUID siteId;

  public ALClient() {
  }

  public ALClient ID(Integer ID) {
    this.ID = ID;
    return this;
  }

   /**
   * The ID of the client.
   * @return ID
  **/
  @javax.annotation.Nullable
  public Integer getID() {
    return ID;
  }

  public void setID(Integer ID) {
    this.ID = ID;
  }


  public ALClient name(String name) {
    this.name = name;
    return this;
  }

   /**
   * The name of the client.
   * @return name
  **/
  @javax.annotation.Nullable
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }


  public ALClient enabled(Boolean enabled) {
    this.enabled = enabled;
    return this;
  }

   /**
   * 
   * @return enabled
  **/
  @javax.annotation.Nullable
  public Boolean getEnabled() {
    return enabled;
  }

  public void setEnabled(Boolean enabled) {
    this.enabled = enabled;
  }


  public ALClient settings(Map<String, String> settings) {
    this.settings = settings;
    return this;
  }

  public ALClient putSettingsItem(String key, String settingsItem) {
    if (this.settings == null) {
      this.settings = new HashMap<>();
    }
    this.settings.put(key, settingsItem);
    return this;
  }

   /**
   * 
   * @return settings
  **/
  @javax.annotation.Nullable
  public Map<String, String> getSettings() {
    return settings;
  }

  public void setSettings(Map<String, String> settings) {
    this.settings = settings;
  }


  public ALClient packages(List<ModelPackage> packages) {
    this.packages = packages;
    return this;
  }

  public ALClient addPackagesItem(ModelPackage packagesItem) {
    if (this.packages == null) {
      this.packages = new ArrayList<>();
    }
    this.packages.add(packagesItem);
    return this;
  }

   /**
   * 
   * @return packages
  **/
  @javax.annotation.Nullable
  public List<ModelPackage> getPackages() {
    return packages;
  }

  public void setPackages(List<ModelPackage> packages) {
    this.packages = packages;
  }


  public ALClient clientSetID(Integer clientSetID) {
    this.clientSetID = clientSetID;
    return this;
  }

   /**
   * 
   * @return clientSetID
  **/
  @javax.annotation.Nullable
  public Integer getClientSetID() {
    return clientSetID;
  }

  public void setClientSetID(Integer clientSetID) {
    this.clientSetID = clientSetID;
  }


  public ALClient siteId(UUID siteId) {
    this.siteId = siteId;
    return this;
  }

   /**
   * 
   * @return siteId
  **/
  @javax.annotation.Nullable
  public UUID getSiteId() {
    return siteId;
  }

  public void setSiteId(UUID siteId) {
    this.siteId = siteId;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ALClient alClient = (ALClient) o;
    return Objects.equals(this.ID, alClient.ID) &&
        Objects.equals(this.name, alClient.name) &&
        Objects.equals(this.enabled, alClient.enabled) &&
        Objects.equals(this.settings, alClient.settings) &&
        Objects.equals(this.packages, alClient.packages) &&
        Objects.equals(this.clientSetID, alClient.clientSetID) &&
        Objects.equals(this.siteId, alClient.siteId);
  }

  @Override
  public int hashCode() {
    return Objects.hash(ID, name, enabled, settings, packages, clientSetID, siteId);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ALClient {\n");
    sb.append("    ID: ").append(toIndentedString(ID)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    enabled: ").append(toIndentedString(enabled)).append("\n");
    sb.append("    settings: ").append(toIndentedString(settings)).append("\n");
    sb.append("    packages: ").append(toIndentedString(packages)).append("\n");
    sb.append("    clientSetID: ").append(toIndentedString(clientSetID)).append("\n");
    sb.append("    siteId: ").append(toIndentedString(siteId)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("ID");
    openapiFields.add("Name");
    openapiFields.add("Enabled");
    openapiFields.add("Settings");
    openapiFields.add("Packages");
    openapiFields.add("ClientSetID");
    openapiFields.add("SiteId");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

 /**
  * Validates the JSON Element and throws an exception if issues found
  *
  * @param jsonElement JSON Element
  * @throws IOException if the JSON Element is invalid with respect to ALClient
  */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!ALClient.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in ALClient is not found in the empty JSON string", ALClient.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!ALClient.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `ALClient` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("Name") != null && !jsonObj.get("Name").isJsonNull()) && !jsonObj.get("Name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `Name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("Name").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("Packages") != null && !jsonObj.get("Packages").isJsonNull() && !jsonObj.get("Packages").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `Packages` to be an array in the JSON string but got `%s`", jsonObj.get("Packages").toString()));
      }
      if ((jsonObj.get("SiteId") != null && !jsonObj.get("SiteId").isJsonNull()) && !jsonObj.get("SiteId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `SiteId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("SiteId").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!ALClient.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'ALClient' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<ALClient> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(ALClient.class));

       return (TypeAdapter<T>) new TypeAdapter<ALClient>() {
           @Override
           public void write(JsonWriter out, ALClient value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public ALClient read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of ALClient given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of ALClient
  * @throws IOException if the JSON string is invalid with respect to ALClient
  */
  public static ALClient fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, ALClient.class);
  }

 /**
  * Convert an instance of ALClient to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

