/*
 * Journey Analytics API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 6.35.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.alterian.ja.model;

import java.util.Objects;
import com.alterian.ja.model.PersonaLink;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import com.alterian.ja.JSON;

/**
 * Provides data about a specific persona.               https://alterian.atlassian.net/l/cp/kQa2X8yb
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", comments = "Generator version: 7.4.0")
public class Persona {
  public static final String SERIALIZED_NAME_ID = "Id";
  @SerializedName(SERIALIZED_NAME_ID)
  private Integer id;

  public static final String SERIALIZED_NAME_ICON = "Icon";
  @SerializedName(SERIALIZED_NAME_ICON)
  private String icon;

  public static final String SERIALIZED_NAME_NAME = "Name";
  @SerializedName(SERIALIZED_NAME_NAME)
  private String name;

  public static final String SERIALIZED_NAME_CREATED = "Created";
  @SerializedName(SERIALIZED_NAME_CREATED)
  private OffsetDateTime created;

  public static final String SERIALIZED_NAME_MODIFIED = "Modified";
  @SerializedName(SERIALIZED_NAME_MODIFIED)
  private OffsetDateTime modified;

  public static final String SERIALIZED_NAME_DESCRIPTION = "Description";
  @SerializedName(SERIALIZED_NAME_DESCRIPTION)
  private String description;

  public static final String SERIALIZED_NAME_HIDDEN = "Hidden";
  @SerializedName(SERIALIZED_NAME_HIDDEN)
  private Boolean hidden;

  public static final String SERIALIZED_NAME_LINKS = "Links";
  @SerializedName(SERIALIZED_NAME_LINKS)
  private List<PersonaLink> links;

  public static final String SERIALIZED_NAME_USAGE_COUNTER = "UsageCounter";
  @SerializedName(SERIALIZED_NAME_USAGE_COUNTER)
  private Integer usageCounter;

  public Persona() {
  }

  public Persona id(Integer id) {
    this.id = id;
    return this;
  }

   /**
   * Internal identifier for the persona
   * @return id
  **/
  @javax.annotation.Nullable
  public Integer getId() {
    return id;
  }

  public void setId(Integer id) {
    this.id = id;
  }


  public Persona icon(String icon) {
    this.icon = icon;
    return this;
  }

   /**
   * Icon
   * @return icon
  **/
  @javax.annotation.Nullable
  public String getIcon() {
    return icon;
  }

  public void setIcon(String icon) {
    this.icon = icon;
  }


  public Persona name(String name) {
    this.name = name;
    return this;
  }

   /**
   * Name of the persona
   * @return name
  **/
  @javax.annotation.Nullable
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }


  public Persona created(OffsetDateTime created) {
    this.created = created;
    return this;
  }

   /**
   * Date the persona was created
   * @return created
  **/
  @javax.annotation.Nullable
  public OffsetDateTime getCreated() {
    return created;
  }

  public void setCreated(OffsetDateTime created) {
    this.created = created;
  }


  public Persona modified(OffsetDateTime modified) {
    this.modified = modified;
    return this;
  }

   /**
   * Date the persona was last modified
   * @return modified
  **/
  @javax.annotation.Nullable
  public OffsetDateTime getModified() {
    return modified;
  }

  public void setModified(OffsetDateTime modified) {
    this.modified = modified;
  }


  public Persona description(String description) {
    this.description = description;
    return this;
  }

   /**
   * Description for the persona
   * @return description
  **/
  @javax.annotation.Nullable
  public String getDescription() {
    return description;
  }

  public void setDescription(String description) {
    this.description = description;
  }


  public Persona hidden(Boolean hidden) {
    this.hidden = hidden;
    return this;
  }

   /**
   * Should this Persona be hidden by default in the UI (as an alternative to deleting it)
   * @return hidden
  **/
  @javax.annotation.Nullable
  public Boolean getHidden() {
    return hidden;
  }

  public void setHidden(Boolean hidden) {
    this.hidden = hidden;
  }


  public Persona links(List<PersonaLink> links) {
    this.links = links;
    return this;
  }

  public Persona addLinksItem(PersonaLink linksItem) {
    if (this.links == null) {
      this.links = new ArrayList<>();
    }
    this.links.add(linksItem);
    return this;
  }

   /**
   * Provides a link to other objects which this persona is being linked to (eg. playbooks, etc.)
   * @return links
  **/
  @javax.annotation.Nullable
  public List<PersonaLink> getLinks() {
    return links;
  }

  public void setLinks(List<PersonaLink> links) {
    this.links = links;
  }


  public Persona usageCounter(Integer usageCounter) {
    this.usageCounter = usageCounter;
    return this;
  }

   /**
   * As events flow through the system, if this persona is detected in the inbound event stream, the usage counter will be incremented.  Note that this             will not be exact but will get an approximation on how often the persona is being used.  Personas which are manually added start with a usage of zero.             Anything with a value greater than zero means that it has been seen in inbound events.
   * @return usageCounter
  **/
  @javax.annotation.Nullable
  public Integer getUsageCounter() {
    return usageCounter;
  }

  public void setUsageCounter(Integer usageCounter) {
    this.usageCounter = usageCounter;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Persona persona = (Persona) o;
    return Objects.equals(this.id, persona.id) &&
        Objects.equals(this.icon, persona.icon) &&
        Objects.equals(this.name, persona.name) &&
        Objects.equals(this.created, persona.created) &&
        Objects.equals(this.modified, persona.modified) &&
        Objects.equals(this.description, persona.description) &&
        Objects.equals(this.hidden, persona.hidden) &&
        Objects.equals(this.links, persona.links) &&
        Objects.equals(this.usageCounter, persona.usageCounter);
  }

  @Override
  public int hashCode() {
    return Objects.hash(id, icon, name, created, modified, description, hidden, links, usageCounter);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Persona {\n");
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    icon: ").append(toIndentedString(icon)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    created: ").append(toIndentedString(created)).append("\n");
    sb.append("    modified: ").append(toIndentedString(modified)).append("\n");
    sb.append("    description: ").append(toIndentedString(description)).append("\n");
    sb.append("    hidden: ").append(toIndentedString(hidden)).append("\n");
    sb.append("    links: ").append(toIndentedString(links)).append("\n");
    sb.append("    usageCounter: ").append(toIndentedString(usageCounter)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("Id");
    openapiFields.add("Icon");
    openapiFields.add("Name");
    openapiFields.add("Created");
    openapiFields.add("Modified");
    openapiFields.add("Description");
    openapiFields.add("Hidden");
    openapiFields.add("Links");
    openapiFields.add("UsageCounter");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

 /**
  * Validates the JSON Element and throws an exception if issues found
  *
  * @param jsonElement JSON Element
  * @throws IOException if the JSON Element is invalid with respect to Persona
  */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!Persona.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in Persona is not found in the empty JSON string", Persona.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!Persona.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `Persona` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("Icon") != null && !jsonObj.get("Icon").isJsonNull()) && !jsonObj.get("Icon").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `Icon` to be a primitive type in the JSON string but got `%s`", jsonObj.get("Icon").toString()));
      }
      if ((jsonObj.get("Name") != null && !jsonObj.get("Name").isJsonNull()) && !jsonObj.get("Name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `Name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("Name").toString()));
      }
      if ((jsonObj.get("Description") != null && !jsonObj.get("Description").isJsonNull()) && !jsonObj.get("Description").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `Description` to be a primitive type in the JSON string but got `%s`", jsonObj.get("Description").toString()));
      }
      if (jsonObj.get("Links") != null && !jsonObj.get("Links").isJsonNull()) {
        JsonArray jsonArraylinks = jsonObj.getAsJsonArray("Links");
        if (jsonArraylinks != null) {
          // ensure the json data is an array
          if (!jsonObj.get("Links").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `Links` to be an array in the JSON string but got `%s`", jsonObj.get("Links").toString()));
          }

          // validate the optional field `Links` (array)
          for (int i = 0; i < jsonArraylinks.size(); i++) {
            PersonaLink.validateJsonElement(jsonArraylinks.get(i));
          };
        }
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!Persona.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'Persona' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<Persona> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(Persona.class));

       return (TypeAdapter<T>) new TypeAdapter<Persona>() {
           @Override
           public void write(JsonWriter out, Persona value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public Persona read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of Persona given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of Persona
  * @throws IOException if the JSON string is invalid with respect to Persona
  */
  public static Persona fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, Persona.class);
  }

 /**
  * Convert an instance of Persona to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

