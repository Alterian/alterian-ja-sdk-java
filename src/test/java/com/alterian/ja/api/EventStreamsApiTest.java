/*
 * Journey Analytics API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 6.35.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.alterian.ja.api;

import com.alterian.ja.ApiException;
import com.alterian.ja.model.AUTHChangePasswordDefaultResponse;
import com.alterian.ja.model.CreateChannelRequest;
import com.alterian.ja.model.CreateClientDefaultResponse;
import com.alterian.ja.model.CreateEventStreamGroupRequest;
import com.alterian.ja.model.CreateEventStreamRequest;
import com.alterian.ja.model.CreateIdealisedJourneyRequest;
import com.alterian.ja.model.CreateSankeyFavouriteRequest;
import com.alterian.ja.model.CreateVisualisationFavouriteRequest;
import com.alterian.ja.model.DeleteChannelRequest;
import com.alterian.ja.model.DeleteEventStreamCustomerColumnsFromGroupRequest;
import com.alterian.ja.model.DeleteEventStreamCustomerColumnsRequest;
import com.alterian.ja.model.DeleteEventStreamGroupRequest;
import com.alterian.ja.model.DeleteEventStreamRequest;
import com.alterian.ja.model.DeleteIdealisedJourneyRequest;
import com.alterian.ja.model.DeleteSankeyFavouritesRequest;
import com.alterian.ja.model.DeleteVisualisationFavouritesRequest;
import com.alterian.ja.model.ExportEventStreamInteractionRequest;
import java.io.File;
import com.alterian.ja.model.GetChannelsDefaultResponse;
import com.alterian.ja.model.GetClientSetsRequest;
import com.alterian.ja.model.GetDataSourceUsersDefaultResponse;
import com.alterian.ja.model.GetEventRecordsDefaultResponse;
import com.alterian.ja.model.GetEventRecordsRequest;
import com.alterian.ja.model.GetEventStreamAggregatesRequest;
import com.alterian.ja.model.GetEventStreamChannelsRequest;
import com.alterian.ja.model.GetEventStreamDecodeMappingsDefaultResponse;
import com.alterian.ja.model.GetEventStreamDecodeMappingsRequest;
import com.alterian.ja.model.GetEventStreamDecodeTargetDiscretesDefaultResponse;
import com.alterian.ja.model.GetEventStreamDecodeTargetDiscretesRequest;
import com.alterian.ja.model.GetEventStreamDefaultResponse;
import com.alterian.ja.model.GetEventStreamDiscreteValuesDefaultResponse;
import com.alterian.ja.model.GetEventStreamDiscreteValuesRequest;
import com.alterian.ja.model.GetEventStreamModelsDefaultResponse;
import com.alterian.ja.model.GetEventStreamModelsRequest;
import com.alterian.ja.model.GetEventStreamRequest;
import com.alterian.ja.model.GetEventStreamsDefaultResponse;
import com.alterian.ja.model.GetFieldTransformationDiscreteValuesRequest;
import com.alterian.ja.model.GetFieldTransformationMappingsDefaultResponse;
import com.alterian.ja.model.GetFieldTransformationMappingsRequest;
import com.alterian.ja.model.GetIdealisedJourneysDefaultResponse;
import com.alterian.ja.model.GetSankeyFavouritesDefaultResponse;
import com.alterian.ja.model.GetSankeyFavouritesRequest;
import com.alterian.ja.model.GetVisualisationFavouritesDefaultResponse;
import com.alterian.ja.model.QueryEventStreamCountDefaultResponse;
import com.alterian.ja.model.QueryEventStreamCountRequest;
import com.alterian.ja.model.QueryEventStreamDefaultResponse;
import com.alterian.ja.model.QueryEventStreamRequest;
import com.alterian.ja.model.QueryEventStreamTransitionRequest;
import com.alterian.ja.model.RunSequencePredictorDefaultResponse;
import com.alterian.ja.model.RunSequencePredictorRequest;
import com.alterian.ja.model.UpdateChannelRequest;
import com.alterian.ja.model.UpdateEventStreamFieldTransformListsRequest;
import com.alterian.ja.model.UpdateIdealisedJourneyRequest;
import com.alterian.ja.model.UpdateSankeyFavouriteRequest;
import com.alterian.ja.model.UpdateVisualisationFavouriteRequest;
import com.alterian.ja.model.UpsertEventStreamCustomerColumnsRequest;
import com.alterian.ja.model.UpsertEventStreamCustomerColumnsToGroupRequest;
import org.junit.jupiter.api.Disabled;
import org.junit.jupiter.api.Test;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * API tests for EventStreamsApi
 */
@Disabled
public class EventStreamsApiTest {

    private final EventStreamsApi api = new EventStreamsApi();

    /**
     * Create a channel colour mapping
     *
     * Create a channel colour mapping
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void createChannelTest() throws ApiException {
        CreateChannelRequest createChannelRequest = null;
        CreateClientDefaultResponse response = api.createChannel(createChannelRequest);
        // TODO: test validations
    }

    /**
     * Creates an event stream, including a datasource and a DDE queue
     *
     * Creates an event stream, including a datasource and a DDE queue
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void createEventStreamTest() throws ApiException {
        CreateEventStreamRequest createEventStreamRequest = null;
        CreateClientDefaultResponse response = api.createEventStream(createEventStreamRequest);
        // TODO: test validations
    }

    /**
     * Creates an event stream group, including a datasource and a DDE queue for each target (dev/test/prod)
     *
     * Creates an event stream group, including a datasource and a DDE queue for each target (dev/test/prod)
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void createEventStreamGroupTest() throws ApiException {
        CreateEventStreamGroupRequest createEventStreamGroupRequest = null;
        CreateClientDefaultResponse response = api.createEventStreamGroup(createEventStreamGroupRequest);
        // TODO: test validations
    }

    /**
     * Create an Idealised Journey
     *
     * Create an Idealised Journey
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void createIdealisedJourneyTest() throws ApiException {
        CreateIdealisedJourneyRequest createIdealisedJourneyRequest = null;
        CreateClientDefaultResponse response = api.createIdealisedJourney(createIdealisedJourneyRequest);
        // TODO: test validations
    }

    /**
     * Create a Sankey Favourite
     *
     * Create a Sankey Favourite
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void createSankeyFavouriteTest() throws ApiException {
        CreateSankeyFavouriteRequest createSankeyFavouriteRequest = null;
        CreateClientDefaultResponse response = api.createSankeyFavourite(createSankeyFavouriteRequest);
        // TODO: test validations
    }

    /**
     * Create a Visualisation Favourite
     *
     * Create a Visualisation Favourite
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void createVisualisationFavouriteTest() throws ApiException {
        CreateVisualisationFavouriteRequest createVisualisationFavouriteRequest = null;
        CreateClientDefaultResponse response = api.createVisualisationFavourite(createVisualisationFavouriteRequest);
        // TODO: test validations
    }

    /**
     * Removed a channel and its associated colour from the channel list.
     *
     * Removed a channel and its associated colour from the channel list.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void deleteChannelTest() throws ApiException {
        DeleteChannelRequest deleteChannelRequest = null;
        AUTHChangePasswordDefaultResponse response = api.deleteChannel(deleteChannelRequest);
        // TODO: test validations
    }

    /**
     * Removes an event stream from the system, optionally purging and deleting the corresponding queue in DDE.  Also can delete the underlying data store if the number of rows in the data store is less than the number provided
     *
     * Removes an event stream from the system, optionally purging and deleting the corresponding queue in DDE.  Also can delete the underlying data store if the number of rows in the data store is less than the number provided
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void deleteEventStreamTest() throws ApiException {
        DeleteEventStreamRequest deleteEventStreamRequest = null;
        AUTHChangePasswordDefaultResponse response = api.deleteEventStream(deleteEventStreamRequest);
        // TODO: test validations
    }

    /**
     * Mark for deletion the specified customer attribute columns for an @see(EventStream).             NOTE THAT THE ASSOCIATED ENGINE COLUMN AND DDE CACHE COLUMN WILL BE DELETED AND ANY DATA LOST PERMANENTLY.             Deletion of the column from Engine and the DDE cache is not synchronous so attempts to recreate the column may fail initially and require a different name to be specified.             Once marked for deletion the columns no longer contribute to the cap imposed by the max number of allowed columns.
     *
     * Mark for deletion the specified customer attribute columns for an @see(EventStream).             NOTE THAT THE ASSOCIATED ENGINE COLUMN AND DDE CACHE COLUMN WILL BE DELETED AND ANY DATA LOST PERMANENTLY.             Deletion of the column from Engine and the DDE cache is not synchronous so attempts to recreate the column may fail initially and require a different name to be specified.             Once marked for deletion the columns no longer contribute to the cap imposed by the max number of allowed columns.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void deleteEventStreamCustomerColumnsTest() throws ApiException {
        DeleteEventStreamCustomerColumnsRequest deleteEventStreamCustomerColumnsRequest = null;
        AUTHChangePasswordDefaultResponse response = api.deleteEventStreamCustomerColumns(deleteEventStreamCustomerColumnsRequest);
        // TODO: test validations
    }

    /**
     * Mark for deletion the specified customer attribute columns for all @see(EventStream)s in a group.             NOTE THAT THE ASSOCIATED ENGINE COLUMN AND DDE CACHE COLUMN WILL BE DELETED AND ANY DATA LOST PERMANENTLY.             Deletion of the column from Engine and the DDE cache is not synchronous so attempts to recreate the column may fail initially and require a different name to be specified.             Once marked for deletion the columns no longer contribute to the cap imposed by the max number of allowed columns.
     *
     * Mark for deletion the specified customer attribute columns for all @see(EventStream)s in a group.             NOTE THAT THE ASSOCIATED ENGINE COLUMN AND DDE CACHE COLUMN WILL BE DELETED AND ANY DATA LOST PERMANENTLY.             Deletion of the column from Engine and the DDE cache is not synchronous so attempts to recreate the column may fail initially and require a different name to be specified.             Once marked for deletion the columns no longer contribute to the cap imposed by the max number of allowed columns.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void deleteEventStreamCustomerColumnsFromGroupTest() throws ApiException {
        DeleteEventStreamCustomerColumnsFromGroupRequest deleteEventStreamCustomerColumnsFromGroupRequest = null;
        AUTHChangePasswordDefaultResponse response = api.deleteEventStreamCustomerColumnsFromGroup(deleteEventStreamCustomerColumnsFromGroupRequest);
        // TODO: test validations
    }

    /**
     * Removes a group of event streams from the system, optionally purging and deleting the corresponding queues in DDE.
     *
     * Removes a group of event streams from the system, optionally purging and deleting the corresponding queues in DDE.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void deleteEventStreamGroupTest() throws ApiException {
        DeleteEventStreamGroupRequest deleteEventStreamGroupRequest = null;
        AUTHChangePasswordDefaultResponse response = api.deleteEventStreamGroup(deleteEventStreamGroupRequest);
        // TODO: test validations
    }

    /**
     * Delete Idealised Journey&#39;s
     *
     * Delete Idealised Journey&#39;s
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void deleteIdealisedJourneyTest() throws ApiException {
        DeleteIdealisedJourneyRequest deleteIdealisedJourneyRequest = null;
        AUTHChangePasswordDefaultResponse response = api.deleteIdealisedJourney(deleteIdealisedJourneyRequest);
        // TODO: test validations
    }

    /**
     * Delete a sankey favourite
     *
     * Delete a sankey favourite
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void deleteSankeyFavouritesTest() throws ApiException {
        DeleteSankeyFavouritesRequest deleteSankeyFavouritesRequest = null;
        AUTHChangePasswordDefaultResponse response = api.deleteSankeyFavourites(deleteSankeyFavouritesRequest);
        // TODO: test validations
    }

    /**
     * Delete Visualisation favourite(s)
     *
     * Delete Visualisation favourite(s)
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void deleteVisualisationFavouritesTest() throws ApiException {
        DeleteVisualisationFavouritesRequest deleteVisualisationFavouritesRequest = null;
        AUTHChangePasswordDefaultResponse response = api.deleteVisualisationFavourites(deleteVisualisationFavouritesRequest);
        // TODO: test validations
    }

    /**
     * Exports the domain of a particular node to return a sample of the CXID (VisitorId) values.             To get the results for \&quot;other\&quot; events pass all displayed events and set &#39;IncludeMatchedEvents&#39; to False.
     *
     * Exports the domain of a particular node to return a sample of the CXID (VisitorId) values.             To get the results for \&quot;other\&quot; events pass all displayed events and set &#39;IncludeMatchedEvents&#39; to False.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void exportEventStreamInteractionTest() throws ApiException {
        ExportEventStreamInteractionRequest exportEventStreamInteractionRequest = null;
        File response = api.exportEventStreamInteraction(exportEventStreamInteractionRequest);
        // TODO: test validations
    }

    /**
     * Return back a list of channels and their associated colours
     *
     * Return back a list of channels and their associated colours
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getChannelsTest() throws ApiException {
        GetChannelsDefaultResponse response = api.getChannels();
        // TODO: test validations
    }

    /**
     * Obtain the event records from an event stream table that match the specified key
     *
     * Obtain the event records from an event stream table that match the specified key
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getEventRecordsTest() throws ApiException {
        GetEventRecordsRequest getEventRecordsRequest = null;
        GetEventRecordsDefaultResponse response = api.getEventRecords(getEventRecordsRequest);
        // TODO: test validations
    }

    /**
     * Return back the full details of an @see(EventStream).  Ids are available from @see(GetEventStreams)
     *
     * Return back the full details of an @see(EventStream).  Ids are available from @see(GetEventStreams)
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getEventStreamTest() throws ApiException {
        GetEventStreamRequest getEventStreamRequest = null;
        GetEventStreamDefaultResponse response = api.getEventStream(getEventStreamRequest);
        // TODO: test validations
    }

    /**
     * Get aggregate stats for an Event Stream.              Currently only supported for JD snapshots (simply because traditional sankey snapshots won&#39;t have the financial columns yet)
     *
     * Get aggregate stats for an Event Stream.              Currently only supported for JD snapshots (simply because traditional sankey snapshots won&#39;t have the financial columns yet)
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getEventStreamAggregatesTest() throws ApiException {
        GetEventStreamAggregatesRequest getEventStreamAggregatesRequest = null;
        GetEventRecordsDefaultResponse response = api.getEventStreamAggregates(getEventStreamAggregatesRequest);
        // TODO: test validations
    }

    /**
     * Requests a list of the channels which the event stream has received.  Use this list to create channel colour mappings @see(CreateChannel).  Use @see(GetEventStreams) for a list of the available @see(EventStream)s
     *
     * Requests a list of the channels which the event stream has received.  Use this list to create channel colour mappings @see(CreateChannel).  Use @see(GetEventStreams) for a list of the available @see(EventStream)s
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getEventStreamChannelsTest() throws ApiException {
        GetEventStreamChannelsRequest getEventStreamChannelsRequest = null;
        GetDataSourceUsersDefaultResponse response = api.getEventStreamChannels(getEventStreamChannelsRequest);
        // TODO: test validations
    }

    /**
     * Given an event stream this API will take an event stream column, sample the data using the specified dates, apply any published transform and then return a cursored list of the labels taking account any decodes that may have been specified             Note that this API does not use any published decode information, if a decode list is to be applied then it should be specified explicitly
     *
     * Given an event stream this API will take an event stream column, sample the data using the specified dates, apply any published transform and then return a cursored list of the labels taking account any decodes that may have been specified             Note that this API does not use any published decode information, if a decode list is to be applied then it should be specified explicitly
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getEventStreamDecodeMappingsTest() throws ApiException {
        GetEventStreamDecodeMappingsRequest getEventStreamDecodeMappingsRequest = null;
        GetEventStreamDecodeMappingsDefaultResponse response = api.getEventStreamDecodeMappings(getEventStreamDecodeMappingsRequest);
        // TODO: test validations
    }

    /**
     * Given an event stream this API will take an event stream column, sample the data using the specified dates, apply any published transform and then return a list of all the currently configured decode targets along with any counts             If a target does not appear in the sampled data it will be returned with a count of zero so it can be optionally filtered out of any picklist
     *
     * Given an event stream this API will take an event stream column, sample the data using the specified dates, apply any published transform and then return a list of all the currently configured decode targets along with any counts             If a target does not appear in the sampled data it will be returned with a count of zero so it can be optionally filtered out of any picklist
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getEventStreamDecodeTargetDiscretesTest() throws ApiException {
        GetEventStreamDecodeTargetDiscretesRequest getEventStreamDecodeTargetDiscretesRequest = null;
        GetEventStreamDecodeTargetDiscretesDefaultResponse response = api.getEventStreamDecodeTargetDiscretes(getEventStreamDecodeTargetDiscretesRequest);
        // TODO: test validations
    }

    /**
     * Obtain discrete values from an event stream table             Supports use of a snapshot table which should reduce the chances of us blowing the Engine discrete limit.             The first parameters constitute the sankey filters and thereby the starting set for discretes             It will also allow us to filter the values by the specified discrete filters             If the sankey filters return no data then an execption is thrown stating that \&quot;No data is available for the specified filters\&quot; as this is probably not what the user wants             If the discretes filter suppresses out all data in the sankey then no exception is raised but zero totals are returned
     *
     * Obtain discrete values from an event stream table             Supports use of a snapshot table which should reduce the chances of us blowing the Engine discrete limit.             The first parameters constitute the sankey filters and thereby the starting set for discretes             It will also allow us to filter the values by the specified discrete filters             If the sankey filters return no data then an execption is thrown stating that \&quot;No data is available for the specified filters\&quot; as this is probably not what the user wants             If the discretes filter suppresses out all data in the sankey then no exception is raised but zero totals are returned
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getEventStreamDiscreteValuesTest() throws ApiException {
        GetEventStreamDiscreteValuesRequest getEventStreamDiscreteValuesRequest = null;
        GetEventStreamDiscreteValuesDefaultResponse response = api.getEventStreamDiscreteValues(getEventStreamDiscreteValuesRequest);
        // TODO: test validations
    }

    /**
     * Retrieve available models
     *
     * Retrieve available models
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getEventStreamModelsTest() throws ApiException {
        GetEventStreamModelsRequest getEventStreamModelsRequest = null;
        GetEventStreamModelsDefaultResponse response = api.getEventStreamModels(getEventStreamModelsRequest);
        // TODO: test validations
    }

    /**
     * Returns back a list of event streams which exist in the system
     *
     * Returns back a list of event streams which exist in the system
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getEventStreamsTest() throws ApiException {
        GetClientSetsRequest getClientSetsRequest = null;
        GetEventStreamsDefaultResponse response = api.getEventStreams(getClientSetsRequest);
        // TODO: test validations
    }

    /**
     * Apply a list of transforms to the discrete values of a column and return the new set of values and their frequencies             If JSONTransforms is not supplied then the results will simply be the discrete values present in the source column after any sample has been applied
     *
     * Apply a list of transforms to the discrete values of a column and return the new set of values and their frequencies             If JSONTransforms is not supplied then the results will simply be the discrete values present in the source column after any sample has been applied
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getFieldTransformationDiscreteValuesTest() throws ApiException {
        GetFieldTransformationDiscreteValuesRequest getFieldTransformationDiscreteValuesRequest = null;
        GetEventStreamDecodeTargetDiscretesDefaultResponse response = api.getFieldTransformationDiscreteValues(getFieldTransformationDiscreteValuesRequest);
        // TODO: test validations
    }

    /**
     * Apply a list of transforms and return information about the transformed value and frequency for each item in the starting set of values             If JSONCompareTransforms is specified then the starting set of values is the result of first applying these to these to the specified column             If JSONCompareTransforms is not specified then the starting set of values is the actual discrete values present in the column
     *
     * Apply a list of transforms and return information about the transformed value and frequency for each item in the starting set of values             If JSONCompareTransforms is specified then the starting set of values is the result of first applying these to these to the specified column             If JSONCompareTransforms is not specified then the starting set of values is the actual discrete values present in the column
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getFieldTransformationMappingsTest() throws ApiException {
        GetFieldTransformationMappingsRequest getFieldTransformationMappingsRequest = null;
        GetFieldTransformationMappingsDefaultResponse response = api.getFieldTransformationMappings(getFieldTransformationMappingsRequest);
        // TODO: test validations
    }

    /**
     * Retrieve a list of Idealised Journeys
     *
     * Retrieve a list of Idealised Journeys
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getIdealisedJourneysTest() throws ApiException {
        GetIdealisedJourneysDefaultResponse response = api.getIdealisedJourneys();
        // TODO: test validations
    }

    /**
     * Retrieve a list of Sankey Favourites
     *
     * Retrieve a list of Sankey Favourites
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getSankeyFavouritesTest() throws ApiException {
        GetSankeyFavouritesRequest getSankeyFavouritesRequest = null;
        GetSankeyFavouritesDefaultResponse response = api.getSankeyFavourites(getSankeyFavouritesRequest);
        // TODO: test validations
    }

    /**
     * Retrieve a list of Visualisation Favourites
     *
     * Retrieve a list of Visualisation Favourites
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getVisualisationFavouritesTest() throws ApiException {
        GetVisualisationFavouritesDefaultResponse response = api.getVisualisationFavourites();
        // TODO: test validations
    }

    /**
     * Queries the domain of selected event records that is represented by the date and event type filters, returning the list of events and graph of transition streams along with frequency counts.             Transitions will specify start and end points using indices into the list of events, along with some special values.             The &#39;Drop off&#39; points where a stream ends will be assigned an index of -1.             Any transition to an event that does not fall into the TopN specification will be assigned to an &#39;other events&#39; category with an index of -2.             Right aligned streams will be left-padded up to the MaxLength specification using a &#39;no event&#39; category with an index of -3.             If timeout events are required then the start of the sequence leading up to a timeout will be flagged with an index of -4 and the end with an index of -5.
     *
     * Queries the domain of selected event records that is represented by the date and event type filters, returning the list of events and graph of transition streams along with frequency counts.             Transitions will specify start and end points using indices into the list of events, along with some special values.             The &#39;Drop off&#39; points where a stream ends will be assigned an index of -1.             Any transition to an event that does not fall into the TopN specification will be assigned to an &#39;other events&#39; category with an index of -2.             Right aligned streams will be left-padded up to the MaxLength specification using a &#39;no event&#39; category with an index of -3.             If timeout events are required then the start of the sequence leading up to a timeout will be flagged with an index of -4 and the end with an index of -5.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void queryEventStreamTest() throws ApiException {
        QueryEventStreamRequest queryEventStreamRequest = null;
        QueryEventStreamDefaultResponse response = api.queryEventStream(queryEventStreamRequest);
        // TODO: test validations
    }

    /**
     * Take the domain of selected event records that is represented by the date filters, and count streams matching the agreed patterns represented by the CountType parameter
     *
     * Take the domain of selected event records that is represented by the date filters, and count streams matching the agreed patterns represented by the CountType parameter
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void queryEventStreamCountTest() throws ApiException {
        QueryEventStreamCountRequest queryEventStreamCountRequest = null;
        QueryEventStreamCountDefaultResponse response = api.queryEventStreamCount(queryEventStreamCountRequest);
        // TODO: test validations
    }

    /**
     * Queries the domain of a particular node to return a sample of the CXID (VisitorId) values.             To get the results for \&quot;other\&quot; events pass all displayed events and set &#39;IncludeMatchedEvents&#39; to False.
     *
     * Queries the domain of a particular node to return a sample of the CXID (VisitorId) values.             To get the results for \&quot;other\&quot; events pass all displayed events and set &#39;IncludeMatchedEvents&#39; to False.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void queryEventStreamInteractionTest() throws ApiException {
        ExportEventStreamInteractionRequest exportEventStreamInteractionRequest = null;
        GetEventRecordsDefaultResponse response = api.queryEventStreamInteraction(exportEventStreamInteractionRequest);
        // TODO: test validations
    }

    /**
     * Queries the domain from a particular node to another node to return a sample of the CXID (VisitorId) values.             To get the results for \&quot;other\&quot; events pass all displayed events and set &#39;IncludeMatchedEventsFrom&#39; / IncludeMatchedEventsTo to False.
     *
     * Queries the domain from a particular node to another node to return a sample of the CXID (VisitorId) values.             To get the results for \&quot;other\&quot; events pass all displayed events and set &#39;IncludeMatchedEventsFrom&#39; / IncludeMatchedEventsTo to False.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void queryEventStreamTransitionTest() throws ApiException {
        QueryEventStreamTransitionRequest queryEventStreamTransitionRequest = null;
        GetEventRecordsDefaultResponse response = api.queryEventStreamTransition(queryEventStreamTransitionRequest);
        // TODO: test validations
    }

    /**
     * Train and employ sequence prediction models for an event stream
     *
     * Train and employ sequence prediction models for an event stream
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void runSequencePredictorTest() throws ApiException {
        RunSequencePredictorRequest runSequencePredictorRequest = null;
        RunSequencePredictorDefaultResponse response = api.runSequencePredictor(runSequencePredictorRequest);
        // TODO: test validations
    }

    /**
     * Updates a channel, allowing you to change the name and colour
     *
     * Updates a channel, allowing you to change the name and colour
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void updateChannelTest() throws ApiException {
        UpdateChannelRequest updateChannelRequest = null;
        AUTHChangePasswordDefaultResponse response = api.updateChannel(updateChannelRequest);
        // TODO: test validations
    }

    /**
     * Publishes the specified transforms to the corresponding event stream columns             Any existing list for a column that matches on Transform Type and Alias will be replaced
     *
     * Publishes the specified transforms to the corresponding event stream columns             Any existing list for a column that matches on Transform Type and Alias will be replaced
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void updateEventStreamFieldTransformListsTest() throws ApiException {
        UpdateEventStreamFieldTransformListsRequest updateEventStreamFieldTransformListsRequest = null;
        AUTHChangePasswordDefaultResponse response = api.updateEventStreamFieldTransformLists(updateEventStreamFieldTransformListsRequest);
        // TODO: test validations
    }

    /**
     * Update an Idealised Journey
     *
     * Update an Idealised Journey
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void updateIdealisedJourneyTest() throws ApiException {
        UpdateIdealisedJourneyRequest updateIdealisedJourneyRequest = null;
        AUTHChangePasswordDefaultResponse response = api.updateIdealisedJourney(updateIdealisedJourneyRequest);
        // TODO: test validations
    }

    /**
     * Update a SankeyFavourite
     *
     * Update a SankeyFavourite
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void updateSankeyFavouriteTest() throws ApiException {
        UpdateSankeyFavouriteRequest updateSankeyFavouriteRequest = null;
        AUTHChangePasswordDefaultResponse response = api.updateSankeyFavourite(updateSankeyFavouriteRequest);
        // TODO: test validations
    }

    /**
     * Update a Visualisation Favourite
     *
     * Update a Visualisation Favourite
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void updateVisualisationFavouriteTest() throws ApiException {
        UpdateVisualisationFavouriteRequest updateVisualisationFavouriteRequest = null;
        AUTHChangePasswordDefaultResponse response = api.updateVisualisationFavourite(updateVisualisationFavouriteRequest);
        // TODO: test validations
    }

    /**
     * Add or update customer attribute columns for an @see(EventStream).             Only updates to column width (that are atomic and have no truncation risk) are currenty supported.              Width only needs to be specified for text or unicode columns.              The number of allowed columns is capped.              Customer attribute columns must maintain discrete cardinality to be used in the Sankey.              Names must meet Engine naming requirements.
     *
     * Add or update customer attribute columns for an @see(EventStream).             Only updates to column width (that are atomic and have no truncation risk) are currenty supported.              Width only needs to be specified for text or unicode columns.              The number of allowed columns is capped.              Customer attribute columns must maintain discrete cardinality to be used in the Sankey.              Names must meet Engine naming requirements.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void upsertEventStreamCustomerColumnsTest() throws ApiException {
        UpsertEventStreamCustomerColumnsRequest upsertEventStreamCustomerColumnsRequest = null;
        AUTHChangePasswordDefaultResponse response = api.upsertEventStreamCustomerColumns(upsertEventStreamCustomerColumnsRequest);
        // TODO: test validations
    }

    /**
     * Add or update customer attribute columns to the @see(EventStream)s in a group.             Only updates to column width (that are atomic and have no truncation risk) are currenty supported.              Width only needs to be specified for text or unicode columns.              The number of allowed columns is capped.              Customer attribute columns must maintain discrete cardinality to be used in the Sankey.              Names must meet Engine naming requirements.             There is some latency (up to 5 mins) between a column being created and the queue service starting to read the data unless the queue service is restarted
     *
     * Add or update customer attribute columns to the @see(EventStream)s in a group.             Only updates to column width (that are atomic and have no truncation risk) are currenty supported.              Width only needs to be specified for text or unicode columns.              The number of allowed columns is capped.              Customer attribute columns must maintain discrete cardinality to be used in the Sankey.              Names must meet Engine naming requirements.             There is some latency (up to 5 mins) between a column being created and the queue service starting to read the data unless the queue service is restarted
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void upsertEventStreamCustomerColumnsToGroupTest() throws ApiException {
        UpsertEventStreamCustomerColumnsToGroupRequest upsertEventStreamCustomerColumnsToGroupRequest = null;
        AUTHChangePasswordDefaultResponse response = api.upsertEventStreamCustomerColumnsToGroup(upsertEventStreamCustomerColumnsToGroupRequest);
        // TODO: test validations
    }

}
